# JavaScript 学习记录

## 简介

1. 跟随视频学习并记录笔记。

2. B站 [视频链接](http://www.bilibili.com/video/av59715096)

3. 外链文档资料大多数来源于W3school，外链资料可作为补充学习，外链连接到大内容的部分需要留意W3school左侧目录附近相关内容。

4. 视频教程分为四部分：
    + JS核心技术 P01-P140
    + JS高级部分 P141-P188
    + ES5、ES6、ES7相关 P189-P222
    + JS模块化

5. 代码按顺序学习，笔记记录也是按顺序，文件名称与笔记标题基本能完成对应。

## JavaScript 核心技术

1. [JS 三种常用输出](https://www.w3school.com.cn/js/js_output.asp)
    + 警告输出 `alert();`
    + 网页页面中输出 `document.write();`
    + 浏览器控制台输出 `console.log();`

2. JS 代码编写位置
    + 标签的事件响应属性中
    + 超链接标签的 href 属性中
    + script 标签中
    + 外部 js 文件，需要在页面中另外引入

3. [基本语法](https://www.w3school.com.cn/js/js_syntax.asp)
    + [注释](https://www.w3school.com.cn/js/js_comments.asp)：多行注释 `/* --- */`；单行注释：`//`
    + JS 中严格区分大小写
    + JS 中每一条语句以分号结尾，如果不写分号，浏览器会自动添加，但是消耗一些系统资源，也可能会加错分号
    + JS 中会忽略多个空格和换行，所以我们可以利用空格和换行来格式化代码

4. 字面量与[变量](https://www.w3school.com.cn/js/js_variables.asp)
    + 字面量都是一些不可改变的值，比如 1，2，3，4，5；字面量都是可以直接使用的，但是我们一般都不会直接使用字面量
    + 变量可以用来保存字面量，而且变量的值是可以任意改变的；变量更加方便我们使用，所以在开发中都是通过变量去保存字面量而不会直接使用字面量。

5. 标识符
    + 在 JS 中所有可以由我们自主命名的都可以称为是标识符，如变量名、函数名、属性名
    + 命名规则：标识符中可以含有字母、数字、_、$；标识符不能以数字开头；标识符不能是ES中的关键字或保留字，[JS中保留字与关键字](https://www.jianshu.com/p/65134425040e)
    + 命名规范：标识符一般都采用驼峰命名法，首字母小写，之后每个单词首字母大写，其余字母小写。
    + JS 底层保存标识符时实际上是采用 Unicode 编码，所以理论上，所有的 utf-8 中含有的内容都可以作为标识符，甚至中文，但是不要使用...

6. [数据类型](https://www.w3school.com.cn/js/js_datatypes.asp)
    + 数据类型指的就是字面量类型
    + 在 JS 中一共由六种数据类型：`String` 字符串，`Number` 数值，`Boolean` 布尔值，`Null` 空值，`Undefined` 未定义，`Object` 对象
    其中 `String`、`Number`、`Boolean`、`Null`、`Undefined` 属于基本数据类型，而 `Object` 属于引用类型。
    + 运算符 `typeof` 来检查一个变量的类型： `typeof a`;
    + `String` 字符串：
      (1) 在 JS 中使用字符串需要使用引号引起来，使用双引号单引号都可以，但是不要混着用，同种类型的引号不能嵌套使用；
      (2) 如果在字符串中需要输出引号等一些特殊符号，可以使用转义字符 `\`，`\"` 表示 `"`, `\'` 表示 `'`，`\n` 表示换行，`\t` 表示制表符，`\\` 表示 `\`，打印斜杠的时候也需要转义。
    + `Number` 数值型：
      (1) 在 JS 中所有的数值都是 `Number` 类型，包括整数和浮点数(小数)；
      (2) JS 中可以表示的数字的最大值：`Number.MAX_VALUE 1.7976931348623157e+308`，如果使用 Number 表示的数据超过了最大值，则会返回 `Infinity` 表示正无穷；`Number.MIN_VALUE` 大于 0 的最小值；
      (3) `NaN` 是一个特殊的数值，表示 Not a Number；在 JS 中整数运算基本可以保证精确，但是进行浮点数计算可能得到一个不精确的结果。
    + `Boolean` 布尔类型：只有两个值：`true` (真)、`false` (假)，用于逻辑判断。
    + `Null` 与 `Undefined`：
      (1) Null 类型的值只有一个，就是 `null`，Null 这个值专门用来表示一个为空的对象，`null` 是一个对象，表示一个空对象。
      (2) Undefined 类型的值只有一个，就是 `undefined`，当声明一个变量，但并不给空对象赋值就使用时它的值就是 `undefined`。

7. 强制[类型转换](https://www.w3school.com.cn/js/js_type_conversion.asp)，将其他数据类型转换为 `String`、`Number`、`Boolean` 类型。
    + 将其他数据类型转换为 String：
      (1) 调用被转换数据类型的 `toString()` 方法，`null` 与 `undefined` 没有 `toString()` 方法，如果调用则报错；
      (2) 调用 `String()` 函数，并将被转换的数据作为参数传入，对于 Number 和 Boolean 实际上就是调用 `toString()` 方法，但是对于 Null 和 Undefined 就不会调用 toSring()，它会将 `null` 直接转换为`"null"`，将 `ndefined` 直接转换为`"undefined"`。
      (3) 使用 `+''` 的当时，即运算时强制转换类型，该方法可以转换 Null 和 Undefined 类型。
    + 将其他数据类型转换为 Number：
      (1) 使用 `Number()` 函数，字符串->数值：将要转换的数据作为参数传入，如果是纯数字字符串则直接转换为数字，只要字符串中含有非数字就转为 `NaN`，如果字符串是空串或者全是空格的字符串则转换为 `0`; 布尔值->数值：`true`：1，`false`：0；Null->数字：0；Undefined->数值：`NaN`；
      (2) `parseInt()` 将字符串解析为整数、`paseFloat()` 将字符串解析为浮点数，此方法专门用于应对字符串转数值，如果对非String 类型使用 `parseInt()` 或 `parseFloat()`，它会先将其转换为 String 然后再操作；可以间接使用 `parseInt()` 来对小数进行取整。
      (3) 使用 `+` 来进行转换，效果跟 Number() 函数一样。
    + 将其他的数据类型转换为 Boolean：使用 `Boolean()` 函数；数值型转布尔型，除了 `0` 和 `NaN` 是 `false`，其余的都是 `true`；字符串转布尔型，只有空串 `''` 是 `false`，其余都是 `true`；`null` 和 `undefined` 转为布尔值，都转换为 `false`；对象类型转 Boolean 也会转换为 `true`。

8. 其他进制数字
    + 在JS中，如果需要表示十六进制的数字，则需要以`0x`开头；如果需要表示八进制的数字，则需要以`0o`开头；如果要表示二进制数字，则需要以`0b`开头，但不是所有的浏览器都支持。
    + 像'070'这样的数字型字符串在使用paseInt()进行解析的时候，有的浏览器会当成八进制进行解析(如IE8)，有的浏览器会当成十进制进行解析；可是在parseInt()中传递第二个参数，来制定数字的进制，如`parseInt(a, 10)`。

9. [运算符](https://www.w3school.com.cn/js/js_operators.asp)(操作符)
    + 通过运算发可以对一个或多个值进行运算，并获取运算结果；比如：`typeof` 就是运算符，可以来获得一个值的类型，它会将该值的类型以字符串的形式返回。
    + 算数运算符:

      | 算术运算符 | 功能说明                                                                                                                                                                                                                                                                                                                                                                                                         |
      | :--------- | :--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
      | `+`        | 对两个值进行加法运算，并将结果返回，对于非数值型的变量进行加法运算，都会先将其转换为 Number 再进行加法运算；所有的值与 `NaN` 相加结果都是 `NaN`；如果对两个字符串进行加法运算，则会将两个字符串进行拼接操作；任何值跟字符串进行加法运算都会将起转换为字符串在进行拼串操作，可以利用该方法将任意类型的变量转换为 `String`，即使用 `+''`，这是一种隐式的类型转换，由浏览器自动完成，实际上是调用 `String()` 函数。 |
      | `-`        | 对两个值进行减法运算，并返回结果                                                                                                                                                                                                                                                                                                                                                                                 |
      | `*`        | 对两个值进行乘法运算                                                                                                                                                                                                                                                                                                                                                                                             |
      | `/`        | 对两个值进行除法运算                                                                                                                                                                                                                                                                                                                                                                                             |
      | `%`        | 取模运算(取余数)                                                                                                                                                                                                                                                                                                                                                                                                 |

      任何值做 `-`、`*` 、`/` 运算时都会自动转换为 Number，可以利用这一点做隐式的类型转换，可以通过对一个值进行 `- 0`、`* 1`、`/ 1`来将其转换为 Number，原理跟 `Number()` 函数一样，使用起来更方便。
    + 一元运算符，只需要一个操作数的运算符：

      | 一元运算符 | 功能说明                                                                                                                                                                |
      | :--------- | :---------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
      | `typeof`   | 返回数据类型                                                                                                                                                            |
      | `+`        | 正号，不对数字产生任何影响                                                                                                                                              |
      | `-`        | 负号，对数字进行取反                                                                                                                                                    |
      | `++`       | 自增，通过自增可以使变量在自身的基础上加1，对于一个变量自增以后变量的值会立即自增1；自增分为两种；`a++`与 `++a`，`++` 在后先执行语句再自增，`++` 在前先自增再执行语句。 |
      | `--`       | 自减，通过自减可以使变量在自身的基础上减1，同样存在 `a--` 与 `--a` 的差异，与自增类似。                                                                                 |

      对于非 Number 类型的值,会先将他转换为 Number，然后在运算；从而可以对一个其他的数据类型使用 `+` 来将其转换为 number，原理跟 `Number()` 函数一样。
    + 逻辑运算符：与或非

      | 逻辑运算符 | 功能说明                                                                                                                                                                                             |
      | :--------- | :--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
      | `!`        | 非，非运算就是对一个布尔值进行取反操作，`!true=false`，`!false=true`;对非布尔值进行运算，会先将其转换为布尔值然后进行运算；任意数据类型可以通过取两次反来转换为布尔值，类似于 Boolean。              |
      | `&&`       | 与，可以对运算符两侧的值进行与运算并返回结果；两个值中,只要有一个为 `false` 就返回 `false`，只有两个值都为 `true` 时才返回 `true`；JS 中的与属于短路与,即如果第一个值为 `false` 则不会再看第二个值。 |
      | `||`       | 或，对运算符两侧的值进行或运算并返回结果；两个值中只要有一个为 `true` 就返回 `true`，只有两个值都为 `false` 时才返回 `false`；JS 中的或属于短路或,即如果第一个值为 `true` 则不会再看第二个值。       |

      对于非布尔值进行与或运算：会先将其转换为布尔值,然后再运算,并返回原来的值。
      与运算：如果第一个值为 `true` 则返回第二个值，如果第一个值为 `false` 则返回第一个值。
      或运算：找 `true` 如果第一个值为 `true` 则直接返回第一个值，如果第一个值为 `false` 则直接返回第二个值。
    + 赋值运算符

      | 赋值运算符 | 功能说明                               |
      | :--------- | :------------------------------------- |
      | `=`        | 可以将符号右侧得值赋值给符号左侧的变量 |
      | `+=`       | `a += 5`等价于`a = a + 5`              |
      | `-=`       | `a -= 5`等价于`a = a - 5`              |
      | `*=`       | `a *= 5`等价于`a = a * 5`              |
      | `/=`       | `a /= 5`等价于`a = a / 5`              |
      | `%=`       | `a %= 5`等价于`a = a % 5`              |

    + 关系运算符，通过关系运算符可以比较两个值之间的大小关系，如果关系成立返回 `true` 否则返回 `false`。
      (1) 与数学中的关系运算符类似：`>`: 大于号、`>=`: 大于等于、`<`: 小于号、`<=`: 小于等于
      (2) 非数值的情况进行比较：非数值型与数值的变量进行比较，会先将其转变为数值型再进行比较；任何值和 `NaN` 做任何比较都是`false`；如果关系运算符两侧都是字符串时，则不会将其转换为数字进行比较，而是分别比较字符串中字符的[Unicode编码](https://baike.baidu.com/item/Unicode%E7%A0%81/7704811)，比较字符串时是一位一位两两进行比较，一样则比较下一位，比较两个字符串型的数字可能会得到不可预期的结果，可以选择将其中任意一个转为数值型。
    + Unicode 编码在网页中的使用
      (1) 在 JS 中，字符串变量中使用转义字符输入 Unicode 编码：`\u四位编码`
      (2) 在 HTML 中，`&#四位编码`;
    + 相等运算符，用来比较两个值是否相等，如果相等返回 `true`，否则返回 `false`

      | 赋值运算符 | 功能说明                                                                                                                                                                                                                                                                                                              |
      | :--------- | :-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
      | `==`       | 等于，做相等比较运算，当比较两个值时，如果两个值类型不同，那么会先将他们转换为相同类型再进行比较；`Undefined` 衍生自 `null`,所以两者做相等判断时,返回 `true`；`NaN` 不和任何值相等,包括它本身，判断一个变量值是否是 `NaN` 需要使用 `isNaN()` 函数来进行判断,变量作为参数传入，如果相等返回 `true`，否则返回 `false`。 |
      | `!=`       | 不等于，用来判断两个值不相等；使用 `!=` 来做不相等运算，不相等也会对变量进行自动类型转换，如果转换后相等它也会返回`false`。                                                                                                                                                                                           |
      | `===`      | 全等，用来判断两个值是否全等，与 `==` 类似，但是不会做类型转换，如果两个变量类型不同，直接返回 `false`。                                                                                                                                                                                                              |
      | `!==`      | 不全等，用来判断两个值是否不全等，与 `!=` 类似，但是不会做类型转换，如果两个变量类型不同，直接返回 `false`。                                                                                                                                                                                                          |

    + 条件运算符，也叫三元运算符、三目运算符：
      (1) 语法：`条件表达式 ? 语句1 : 语句2`;
      (2) 执行流程：条件运算符在执行时，首先对条件表达式进行求值，如果该值为true则执行语句1并返回执行结果，如果该值为false则执行语句2并返回执行结果。
      (3) 如果条件表达式的值为非布尔值，那么会先将其传唤为布尔值在进行运算。
    + 逗号运算符：`,` 使用逗号运算符可以分割多个语句，一般可以在声明多个变量时使用。
    + 运算符的优先级，和数学中的运算符优先级类似，如先乘除，后加减。在 JS 中有一个运算发优先级的表，在表中位置越靠上优先级越高，优先级越高越先计算，优先级一样则从左往右进行计算。

      | 运算符优先级(越靠上优先级越高)                                            |
      | :------------------------------------------------------------------------ |
      | `.`、`[]`、`new`                                                          |
      | `()`                                                                      |
      | `++`、`--`                                                                |
      | `!`、`~`、`+` (单目)、`-` (单目)、`typeof`、`void`、`delete`              |
      | `%`、`*`、`/`                                                             |
      | `+` (双目)、`-` (双目)                                                    |
      | `<<`、`>>`、`>>>`                                                         |
      | `<`、`<=`、`>`、`>=`                                                      |
      | `==` 、`!==` 、`===`                                                      |
      | `&`                                                                       |
      | `^`                                                                       |
      | `|`                                                                       |
      | `&&`                                                                      |
      | `||`                                                                      |
      | `?:`                                                                      |
      | `=`、`+=`、`-=`、`*=`、`/=`、`%=`、`<<=`、`>>=`、`>>>=`、`&=`、`^=`、`|=` |
      | `,`                                                                       |

10. [语句](https://www.w3school.com.cn/js/js_statements.asp)和代码块
    + 程序是由一条条语句构成的，语句时按照自上向下的顺序一条条执行的。
    + 在 JS 中可以使用 `{}` 花括号来为语句进行分组，同一个 `{}` 中的语句我们称之为一组语句，或者称之为代码块，她们要么都执行，要么都不执行，代码块后面就不用再写分号了。
    + JS 中的代码块只具有分组的作用，没有其他的用途，即代码块中的内容，在外部是完全可见的。

11. 流程控制语句，JS 中的程序是从上到下一行一行执行的，通过使用流程控制语句可以控制程序执行流程，可以使程序可以根据一定的条件来选择执行。
    + [条件判断](https://www.w3school.com.cn/js/js_if_else.asp)(选择)语句，使用条件判断语句可以在执行某条语句之前进行判断，如果条件成立才会执行语句，条件不成立则语句不执行。
      (1) 语法一：

        ``` JavaScript
        if(条件表达式)
          语句
        ```

      `if` 语句在执行时会先对条件表达式进行求值判断，如果条件表达式的值为 `true` ,则执行 `if` 后的语句，如果条件表达式的值为false则不会执行 `if` 后的语句；`if` 语句只能控制紧随其后的那一条语句，要想控制多条语句则需要将多条语句放到代码块，`if` 语句后的代码块不是必须的，但是在开发中尽量写上。
      (2) 语法二:

        ``` JavaScript
        if(条件表达式){
          语句...
        }else{
          语句...
        }
        ```

      `if else`语句，当该语句执行时，会先对 `if` 后的条件表达式进行求值判断，如果该值为 `true`,则执行 `if` 后的语句,如果该值为 `false` 则执行 `else` 后的语句。
      (3) 语法三：

        ``` JavaScript
        if(条件表达式){
          语句...
        }else if(条件表达式){
          语句...
        }else if(条件表达式){
          语句...
        }else{
          语句...
        }
        ```

      `if else` 语句，当该语句执行时,会从上到下一次对条件表但是进行求值判断，如果值为 `true` 则执行当前语句，如果值为 `false`，则继续向下判断，如果所有条件都不满足，则执行最后的一个 `else` 语句；该语句中，只会有一个代码块被执行，一旦代码块执行了，则直接结束语句。
    + [条件分支语句](https://www.w3school.com.cn/js/js_switch.asp)，switch 语句
      (1) 语法：

        ``` JavaScript
        switch(条件表达式){
          case 表达式:
            语句...
            break;
          case 表达式:
            语句...
            break;
          case 表达式:
            语句...
            break;
          ...
          default:
            语句...
            break;
        }
        ```

      (2) 执行流程：在执行时会依次将 `case` 后的表达式的值和 `switch` 后的条件表达式的值进行全等比较，如果比较结果为 `true`，则当前的 `case` 处开始执行代码(之后的所有代码，需要使用 `break;` 来退出switch语句)，如果比较结果为 `false` 则继续向下比较，如果所有的条件都不满足则会执行最后的 `default` 中的语句。
      (3) switch 语句与 if 语句功能上实际上有重复，使用 switch 实现的功能可以通过 if 来实现，同样使用 if 实现的功能也能通过 switch 来实现。
    + 循环语句：通过循环语句可以反复的执行一段代码多次
      (1) [while循环](https://www.w3school.com.cn/js/js_loop_while.asp):
      语法：

        ``` JavaScript
        while(条件表达式){
          语句...
        }
        ```

      执行过程：先对条件表达式进行求值判断，如果值为 `true` 则执行循环体，循环体执行完毕后，继续对表达式进行判断，如果为 `true`，则继续执行循环体，依次类推，直到值为 `false` 则终止循环
      (2) `do while` 循环
      语法:

        ```JavaScript
        do{
            语句...
        }while(条件表达式)
        ```

      执行过程：先执行循环体，循环体执行完毕之后，才对 `while` 后的条件表达式进行判断，如果结果为 `true`，则会继续执行循环体，执行完毕继续判断依次类推，如果结果为 `false`，则终止循环。
      实际上这两个语句功能类似，不同的是 `while` 实现判断后执行，`do while` 是先执行后判断。所以 `do while` 可以保证循环体至少执行一次。
      (3) [for循环](https://www.w3school.com.cn/js/js_loop_for.asp)，for 语句也是一个循环语句，也称为 for 循环。在 for 循环中为我们提供了专门的位置用来方三个表达式：初始化表达式，条件表达式，更新表达式。
      语法：

        ``` JavaScript
        for(初始化表达式; 条件表达式; 更新表达式){
          语句...
        }
        ```

      执行流程：先执行初始化表达式，初始化变量；执行条件表达式，判断是否执行循环，如果为 `true` 则执行循环，如果为 `false` 则终止循环；循环体执行完后执行更新表达式；重复判断条件表达式和执行循环。初始化表达式只在开始执行了一次。
      for循环可以嵌套，即一个for循环里还可以嵌套一个for循环，从而能够灵活的进行流程控制。
    (4) [break 和 continue](https://www.w3school.com.cn/js/js_break.asp)：`break` 关键字可以用来退出 switch 或循环语句，不能单独在 if 语句中中使用 `break` 和 `continue` 关键字。`break` 默认只能终止当前循环，可以为循环语句创建一个 label，来表示当前的循环，label：循环语句，使用 `break` 语句是，可以在 `break` 后跟一个label，这样 `break` 将会结束指定的循环，而不是当前循环。continue关键字可以用来跳过当次循环。

12. [对象](https://www.w3school.com.cn/js/js_objects.asp)
    + JS 中的数据类型：String 字符串、Number 数值、Boolean 布尔值、Null 空值、Undefined 未定义(以上者五种类型属于基本数据类型，以后只要看到的之不是上面5种，则全都是对象类型)、Object 对象。如果使用基本数据类型的数据，我们所创建的变量都是独立的，不能成为一个整体，这就引出了对象的需求；对象属于一种复合的数据类型，在对象中可以保存多个不同的数据类型的属性。
    + 对象的分类:
      (1) 内建对象：由 ES 标准中定义的对象，在任何的 ES 的实现中都可以使用，比如 Math String Number Boolean Function Object...
      (2) 宿主对象：由 JS 的运行环境提供的对象，目前来讲主要值由浏览器提供的对象，比如DOM、BOM。
      (3) 自定义对象，由开发人员自己创建的对象。
    + 对象的基本操作：
      (1) 创建一个对象，使用 `new` 关键字调用的函数，是构造函数 `constructor`，构造函数是专门用来创建对象的函数。使用 `typeof` 返回变量类型会返回 `object`。
      (2) 在对象中保存的值称为属性，向对象添加属性，语法：`对象.属性名 = 属性值;`
      (3) 读取对象中的属性，语法：`对象.属性名`；如果读取对象中没有的属性，不会报错，而是返回 `undefined`。
      (4) 修改对象的属性值，语法：`对象.属性名 = 新属性值;`
      (5) 删除对象的属性，语法：`delete 对象.属性名;`
    + 属性名与属性值：
      (1) 属性名：对象的属性名不强制要求遵守标识符的规范，但是使用的时候尽量还是遵循标志符的规范。如果要使用特殊的属性名不能采用 `.` 的方式来操作，需要使用另一种方式，语法：`对象["属性名"] = 属性值;` 读取的时候也需要采用这种方式。使用 `[]` 这种形式去操作属性，更加的灵活，在 `[]` 中可以直接传递一个变量，这样变量值是多少就会读取那个属性名对应的属性值。
      (2) 属性值：JS 对象的属性值，可以是任意的数据类型，甚至也可以是一个对象。
      (3) `in` 运算符：通过 `in` 运算符可以检查一个对象中是否含有指定的属性，如果有则返回 `true`，没有则返回 `false`。
    + 基本数据类型和引用数据类型：
      (1) JS 中的变量都是保存到栈内存中的，基本数据类型的值直接在栈内存中进行存储，值与值之间都是独立存在，修改一个变量不会影响其他的变量。引用数据类型(对象)是保存到堆内存中的，每创建一个新的对象，就会在堆内存中开辟出一个新的空间，而变量保存的是对象的内存地址(对象的引用)。如果两个变量保存的是同一个对象的引用，那么当一个变量修改属性时，另一个也会受到影响。
      (2) 修改对象变量的值不会对对象产生影响，实际上是将地址换为了其他值。
      (3) 当比较两个基本数据类型的值的时候就是比较的这两个值；而比较两个引用数据类型时，它是比较的对象的内存地址，两个对象即使一摸一样但是也不一定相等，因为实际上是比较两个地址，地址不同则不相等。
    + 对象字面量
    使用对象字面量，可以在创建对象时，直接指定对象的属性。语法：`{属性名: 属性值, 属性名: 属性值...}`;
    对象字面量的属性名可以加引号，也可以不加，建议不加，如果要使用一些特殊的名字，则必须加引号；属性名和属性值是一组一组的键值对(`key-value`)结构，最后一对的时候就不用写 `,` 分隔符了。

13. [函数](https://www.w3school.com.cn/js/js_functions.asp)
    + 函数也是一个对象，函数中可以封装一些功能(代码)，在需要是可以执行这些功能(代码)。函数可以保存一些代码，在需要的时候调用。使用 `typeof` 检查一个函数的类型时，会返回 `function`。封装到函数中的代码不会立即执行，函数中的代码会在函数调用的时候执行,调用函数语法：`函数对象()`，当调用函数时，函数中封装的代码会按顺序执行。
    + 函数的创建
      (1) 调用构造函数创建一个函数
      语法：

        ``` JavaScript
        var 函数名 = new Function("函数中执行的代码");
        ```

      然而使用构造函数创建一个函数对象很不方便，所以实际中很少使用此方法。
      (2) 使用函数声明来创建一个函数
      语法:

        ``` JavaScript
        function 函数名(形参1, 形参2, ...){
            语句...
        }
        ```

      (3) 使用函数表达式来创建一个函数
      语法：

        ``` JavaScript
        var 函数名 = function(形参1, 形参2, ...){
                      语句...
                    };
        ```

    + 函数的参数
      (1) 可以在函数的 `()` 中指定一个或多个形参(形式参数)，多个形参之间使用 `,` 隔开，声明形参就相当于在函数内部声明对应的变量，但并不赋值，调用函数时，可以在 `()` 中指定实参(实际参数)，实参会赋值给函数中对应的形参。
      (2) 调用函数时解析器不会检查实参的类型，所以在调用函数的时候要注意是否有可能会接收到非法的参数，如果有可能则需要对参数进行类型的检查。调用函数时，解析器也不会检查实参的数量，多余的实参不会被赋值，如果实参的数量少于形参的数量，则没有对应实参的形参将是 `undefined`。函数的实参可以是任意数据类型。
    + 函数的返回值
      (1) 可以使用 `return` 关键字设置函数的返回值，语法：`return 值;`，`return` 后的值将会作为函数的执行结果返回。
      (2) 在函数中 `return` 之后的语句都不会执行了，如果 `return` 之后不跟任何值就相当于返回一个 `undefined`，如果函数中不写 `return`，也会返回 `undefined`；`return` 可以返回任意类型的值。
    + 函数的参数可以是任意值：函数的对象可以是任何值，如 String、Number 等基本数据类型；当需要传递的参数过多时可以考虑使用 Object 类型，传递一个对象类型；甚至可以传递一个函数，当传递函数时，如果传递函数时使用 `函数名()` 的话，相当于调用函数，会使用函数的返回值，若使用“函数名”传递的是函数对象，相当于直接使用函数对象。
    + 函数返回值的类型：
      (1) `break`，`continue`，`return` 区别：使用 `break` 可以退出当前的循环，使用 `continue` 可以跳过当此循环，使用`return` 可以结束整个函数/循环。
      (2) 返回值可以是任意的数据类型，也可以是一个对象，也可以是一个函数。
    + 立即执行函数：函数定义完之后立即调用，只执行一次。用一个括号来包裹一个匿名函数，说明这是一个整体的函数对象，然后在这个函数对象之后再加一对括号来调用函数，同样也可以在调用的时候传递参数。
    + 方法：函数也可以成为对象的属性，如果一个函数作为一个对象的属性保存，那么我们称这个函数是这个对象的方法(method)，调用这个函数就称为调用对象的方法，只是说法上不同，本质一样。
    + 枚举对象中的属性，在不清楚一个未知对象中的属性多少的情况下，可以使用 `for in` 语句进行枚举，
      语法:

      ``` JavaScript
      for(var 变量 in 对象){

      }
      ```

      `for in` 语句遍历对象时，对象总共有几个属性，就循环执行几次，每次执行时，会将对象中的一个属性的名字赋值给变量。
    + 在函数对象中有两个方法[call()](https://www.w3school.com.cn/js/js_function_call.asp)与[apply()](https://www.w3school.com.cn/js/js_function_apply.asp)，需要通过函数来调用；当函数调用 `call()` 和 `apply()` 方法时，都会调用函数执行；`call()` 方法可以将实参在函数对象之后依次传递，`apply()` 方法需要将实参封装到一个数组中统一传递。
    + 到目前为止 `this` 的指向情况，基本就这些：以函数的形式调用时，`this` 永远指向 window；以方法的形式调用时，`this` 指向调用方法的对象；以构造函数形式调用用，`this` 指向新创建的对象；使用 `call()` 和 `apply()` 调用时，`this` 是指定的那个对象。
    + 函数的参数列表(arguments)：在调用函数时，浏览器每次都会传递进两个隐含的参数，一个是函数的下文对象 `this`，另一个是封装实参的对象 `arguments`；`arguments` 是一个类数组对象，虽不是一般的数组，但是可以像数组一样获取长度，`arguments` 的长度就是实参的个数；在调用函数时，我们所传递的实参都会在 `arguments` 中保存，所以即使不定义形参也能通过 `arguments` 来使用实参，只不过比较麻烦，`arguments[0]` 第一个实参 `arguments[1]` 第二个实参。`arguments` 里面有一个属性叫 `callee`，这个属性对应一个函数对象，就是当前正在执行的函数对象。

14. [作用域](https://www.w3school.com.cn/js/js_scope.asp)(scope)
    + 作用域指一个变量的作用范围，在 JS 中一共有两种：全局作用域和函数作用域(局部作用域)。
    + 全局作用域：
      (1) 直接写在 script 标间中的 JS 代码，都是全局作用域；
      (2) 全局作用域在页面打开时创建，页面关闭时销毁；
      (3) 在全局作用域中有一个全局对象 window，我们可以直接使用，它代表浏览器的窗口，它由浏览器创建；在全局作用域中创建的变量都会作为 window 的属性，在全局作用域中创建的函数都会作为 window 的方法。
      (4) 全局作用域中的变量都是全局变量，在页面的任意位置都可以访问的到。
    + 变量与函数的声明提前：
      (1) 变量的声明提前，使用 `var` 关键字生命声明的变量，会在所有的代码执行之前被声明(但是要执行到当前行才会赋值)；但是如果声明变量时不使用 `var` 关键字，则变量不会被声明提前。
      (2) 函数的声明提前，使用函数声名形式创建的函数，它会在所有代码执行之前就被创建，所以可以在函数声明之前调用函数；使用函数表达式创建的函数，不会被声明提前，所以不能在函数赋值之前调用。
    + 函数作用域(局部作用域)：
      (1) 调用函数时创建函数作用域，函数执行完毕之后，函数作用域销毁；每调用一次函数就会创建一个新的函数作用域，它们之间相互独立；
      (2) 在函数作用域中可以访问到全局作用域的变量，在全局作用域中无法访问到函数作用域中的变量；当在函数作用域操作一个变量时，它会先在自身作用域中寻找，如果有就直接使用如果没有则向上一级作用域中寻找，直到找到全局作用域，如果依然没有找到，则会报错 `ReferenceError`；在函数作用域中要访问全局作用域中的变量，可以使用 window 对象；
      (3) 在函数作用域中也有声明提前的特征，使用 `var` 关键字声明的变量，会在函数中所有的代码执行之前被声明，函数声明也会在所有的代码执行之前执行；
      (4) 定义形参就相当于在函数作用域中声明了变量

15. [this 指针](https://www.w3school.com.cn/js/js_this.asp)
    + 解析器在调用函数时，每次都会向函数内部传递一个隐含的参数，这个隐含参数就是 `this`，`this` 指向的是一个对象，这个对象我们称为函数执行的上下文对象；
    + 根据函数调用的方式不同，`this` 会指向不同的对象：以函数的形式调用时 `this` 永远都是window，以方法的形式调用时 `this` 就是调用该方法的那个对象；本质上是一样的，因为 window 本质也是一个对象，调用函数实际上就是调用 window 对象的方法。

16. 对象进阶
    + 使用工厂方法创建对象：对于拥有相同属性的不同对象，可以考虑抽离出一个函数来创建对象并在函数中为对象添加属性和方法并最终返回该对象，使用工厂方法可以快速批量创建对象。
    + 使用[构造函数](https://www.w3school.com.cn/js/js_object_constructors.asp)(类)创建对象：
      (1) 使用构造函数创建对象，构造函数就是一个普通函数，创建方式和普通函数没有区别，不同的是构造函数习惯上首字母大写。构造函数和普通函数的区别就是调用方式的不同，普通函数是直接调用，而构造函数需要使用 `new` 关键字调用。
      (2) 构造函数执行流程：一开始立刻创建一个新的对象，将新建的对象设置为函数中的 `this` 在构造函数中可以使用 `this` 来逐行创建对象，逐行执行函数中的代码(用户只需要操作该部分)，将新建的对象作为返回值返回。
      (3) 使用同一个构造函数创建的对象，我们称为一类对象，也将一个构造函数称为一个类，我们将通过一个构造函数创建的对象称为时该构造对象的实例或者该类的实例。
      (4) 使用 `instanceof` 关键字可以检查一个对象是否是一个类的实例，是则返回 `true`，否则返回 `false`；所有的对象都是 Object 的后代，所以任何对象和 Object 做 `instanceof` 检查时都会返回 `true`。
      (5) `this` 补充：当以函数的形式调用时，`this` 指向 `window`；当以方法形式调用时，`this` 指向调用该方法的对象；当以构造函数形式调用时，this就是新创建的那个对象。
      (6) 使用构造函数(类)创建的对象可以避免了使用 Object 创建对象带来的不可识别对象类的问题。
      (7) 目前我们的方法是在构造函数内创建的，也就是构造函数每执行一次就会创建一个新的方法，也就是所有的实例的该方法都是唯一的，这样就导致构造函数每执行一次就会创建一个新方法，然而这样完全没有必要(占用内存等缺陷)，完全可以使所有的对象共享同一个方法。解决方法可以将函数定义到外部全局作用域，但是这样有带来了新的问题：将函数定义在全局作用域中，污染了全局作用域的命名空间，而且定义在全局作用域中也很不安全。
    + [原型](https://www.w3school.com.cn/js/js_object_prototypes.asp)(`prototype`)对象
      (1) 我们所创建的每一个函数，解析器都会向函数中添加一个属性 `prototype`，这个属性对应着一个对象，这个对象就是我们所谓的原型对象。
      (2) 如果函数作为普通函数调用 `prototype` 没有任何作用，当函数以构造函数调用时他所创建的对象中都会有一个隐含的属性，指向构造函数的原型对象，我们可以通过 `__proto__` 来访问该属性。
      (3) 当访问对象的一个属性或方法的时候现在对象自身中寻找，如果有则直接使用，如果没有则去原型对象中寻找，如果找到则直接使用。
      (4) 以后创建构造函数时，可以将这些对象共有的属性和方法，统一添加到构造函数的原型对象中，这样不用分别为每一个对象添加，也不会影响到全局作用域，就可以使每个对象都具有这些属性和方法了。
      (5) 使用 `in` 检查对象中是否含有某个属性时，如果对象中没有但是原型中有，也会返回 `true`；可以使用对象的  `hasOwnProperty()` 来检查对象自身中是否含有该属性，使用该方法只有当对象自身中含有属性时，才会返回 `true`。
      (6) 原型链：原型对象也是对象，所以它也有原型，当我们使用一个对象的属性或方法时，会先在自身中寻找，自身中如果有则直接使用，如果没有则去原型中找如果有则直接使用，如果没有则去原型的原型中寻找，直到找到 `Object` 对象的原型，`Object` 原型对象没有原型，如果在 `Object` 中依然没有找到，则返回 `undefined`。
    + 对象的 `toString()`：当我们直接在页面中打印一个对象时，实际上时输出的对象的 `toString()` 方法的返回值；如果我们希望在输出对象时不输出 `[object Object]`，则可以为对象添加一个 `toString()` 方法，如果需要在同一类的不同对象多次输出对象，需要修改对象原型的 `toString()`，进而对象原型的所有实例的都使用这个 `toString()`。
    + 垃圾回收(garbage collection)
      (1) 就像人们生活一样，程序运行过程中也会产生垃圾，这些垃圾积攒过多以后会导致程序运行速度过慢，所以我们需要一个垃圾回收机制，来处理程序运行过程中产生的垃圾。
      (2) 当一个对象没有任何的变量或属性对他进行引用，此时我们将用于无法操作该对象，此时这种对象就是一个垃圾，这种对象过多会占用大量内存空间，会导致程序运行变慢，所以这种垃圾必须进行清理。
      (3) 在 JS 中拥有自动的垃圾回收机制，会自动将这些垃圾从内存中销毁，我们不需要也不能进行垃圾回收的操作，我们只需要将不再使用的对象设置为 `null` 即可。

17. [数组](https://www.w3school.com.cn/js/js_arrays.asp)(Array)
    + 数据是 ES 标准的一个内建对象，数组也是一个对象，使用 `typeof` 检查一个数组时，会返回 Object，它和普通的对象功能类似，也是用来存储一些值的，不同的是普通对象是使用字符串作为属性名的，而数组是使用数字来作为索引(Index)操作元素的。
    + 索引：从 0 开始的整数就是索引
    + 数组的存储性能比普通对象更好，在开发中我们经常使用数组来存储一些数据。
    + 数组的基本操作：
      (1) 使用构造函数创建数组，语法：`var 数组名 = new Array();`
      (2) 向数组中添加元素，语法：`数组名[索引] = 值;`
      (3) 读取数组中的元素，语法：`数组名[索引]`；如果读取不存在的索引，不会报错而是返回 `undefined`；
      (4) 数据的长度属性 `length`：获取数组的长度，使用 `length` 属性获取数组的长度(元素的个数)，语法：`数组名.length;` 对于连续的数组，使用 `length` 属性可以获取到数组的长度(元素的个数)，对于非连续的数组，使用 `length` 属性会获取到最大的索引+1，尽量不要创建非连续的数组。同样还可以通过 `length` 属性来修改数组的长度，如果修改的 `length` 大于原长度，则多出的部分会空出来，如果修改的 `length` 小于原长度，则多出的元素会被删除。巧用 `length` 属性，向数组的最后一个位置添加元素：`数组名[数组名.length] = 值`;
      (5) 使用字面量创建数组：语法：`var 数组名 = [];` 使用字面量创建数组时，可以同时指定数组中的元素，元素之间使用英文逗号隔开，其实使用构造函数创建数组时也可以指定数组中的元素，只要在创建时在 `Array()` 括号中给定元素即可；当然两者也有一点区别：当只给定一个元素时使用字面量时创建的只有一个元素的数组，而构造函数方式是创建一个长度为给定长度的数组。
      (6) 数组中的元素可以是任意的数据类型，甚至是对象、函数和数组。
    + 数组的常用方法：

      | 方法名      | 功能说明                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       |
      | :---------- | :--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
      | `push()`    | 该方法可以像数组的末尾添加一个或多个元素，并返回数组的新长度，可以将要添加的元素作为方法的参数传递，这样这些元素将会自动添加到数组的末尾。                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     |
      | `pop()`     | 该方法可以删除数组的最后一个元素，并将被删除的元素作为返回值返回。                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             |
      | `unshift()` | 该方法向数组的开头添加一个或多个元素，并返回新的数组长度，向前面插入元素之后，其他的元素索引会依次调整。                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       |
      | `shift()`   | 该方法从数组的开头删除一个元素，并返回该元素。                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 |
      | `forEach()` | 该方法用于遍历数组，这个方法需要 IE8 以上浏览器才支持，其他浏览器基本都支持。这个方法需要一个函数作为参数，像这种函数，由我们创建但是不由我们调用的，我们称为回调函数；数组中有几个元素函数就会执行几次，每次执行的时候浏览器会将遍历到的元素以实参的形式传递过来，我们可以定义形参，来读取这些内容; 浏览器会在回调函数中传递三个参数：第一个参数就是当前遍历到的元素，第二个参数就是当前遍历到的元素的索引，第三个参数就是正在遍历的数组。                                                                                                                                                                                                    |
      | `slice()`   | 这个函数可以从数组中提取指定元素，该方法不会改变原数组而是把截取到的元素封装到一个新数组中并返回；参数：第一个参数为截取开始的位置索引(包含)，第二个参数为截取结束的位置索引(不包含)；第二个参数可以不写，此时会截取从开始位置往后的所有元素；索引可以传递一个负值，如果传递一个负值，则从后往前计算，如 -1 为倒数第一个，-2 为倒数第二个。                                                                                                                                                                                                                                                                                                    |
      | `splice()`  | 这个方法可以用于删除数组中的指定元素，使用 `splice` 会影响到原数组，会将指定元素从原数组中删除，并将删除的元素作为返回值返回；参数：第一个参数为开始位置的索引，第二个参数为删除元素的数量，第三个及以后的参数为要插入的新元素，插入到开始索引的前面。                                                                                                                                                                                                                                                                                                                                                                                         |
      | `concat()`  | 该方法可以链接两个或多个数组，并将新的数组返回；该方法不会对原数组产生影响。                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   |
      | `join()`    | 该方法可以将数组转换为一个字符串，并将转换的字符串返回；在 `join()` 方法中可以指定一个字符串作为参数，这个字符串将会成为数组中元素的连接符，默认为逗号；该方法不会对原数组产生影响。                                                                                                                                                                                                                                                                                                                                                                                                                                                           |
      | `reverse()` | 该方法用来反转数组；该方法会直接修改原数组。                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   |
      | `sort()`    | 该方法会对数组中的元素进行排序，默认会按照 Unicode 编码进行排序，即使是对数字进行排序也是使用 Unicode 编码进行排序,所以可能会得到错误的数组排序；我们可以在 `sort()` 方法中添加一个回调函数，来指定排序规则，回调函数中需要定义两个形参，浏览器将会分别使用数组中的元素来作比较，实参去调用回调函数，使用哪个元素不确定，但是肯定是在数组中第一个参数(a)一定在第二个参数(b)前面；浏览器会根据回调函数的返回值来决定元素的顺序，如果返回一个大于0的值则元素会将换位置，如果返回一个小于 0 的值则元素位置不变，如果返回一个 0 则认为两个元素相等，也不交换位置；如果需要升序则返回(a - b)，如果需要降序则返回(b - a)；该方法也会直接修改原数组。 |
      | `isArray()` | 除了使用 `instance of` 关键字来检查一个对象是否是数组外，还可以使用 `Array.isArray(对象名);` 来判断。                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          |

18. [日期](https://www.w3school.com.cn/js/js_dates.asp)(Date)
    + 在 JS 中使用 Date 对象来表示一个时间，如果直接使用构造函数创建一个 Date 对象，则会封装为当前代码执行的时间，创建指定的时间对象,需要在构造函数中传递一个表示时间的字符串作为参数，字符串日期的格式：“月份/日/年 时:分:秒”。
    + 常用方法：

      | 方法名          | 功能说明                                                                                                                                                |
      | :-------------- | :------------------------------------------------------------------------------------------------------------------------------------------------------ |
      | `getDate()`     | 获取当前日期对象是几日。                                                                                                                                |
      | `getDay()`      | 获取当前日期对象是周几，会返回一个 0-6 的值，表示周日。                                                                                                 |
      | `getMonth()`    | 获取当前日期对象是几月，会返回一个 0-11 的值，0 表示一月。                                                                                              |
      | `getFullYear()` | 获取当前日期对象的年份                                                                                                                                  |
      | `getTime()`     | 获取当前日期的时间戳，时间戳指的是从格林威治标准时间 1970 年 1 月 1 日 0 时 0 分 0 秒到当前日期所花费的毫秒数，计算机底层在保存时间时都是使用的时间戳。 |
      | `Date.now()`    | 获取当前的时间戳，代码执行到此处时的时间戳，可以使用它来测试代码性能。                                                                                  |

19. Math
    + Math 和其他对象不同，他不是一个构造函数，它属于一个工具类，不用创建对象，它里面封装了数学运算相关的属性和方法，属性与方法的使用一般都是以 `Math.` 开头的形式使用，比如 `Math.PI` 表示圆周率。
    + 常用方法：

      | 方法名      | 功能说明                                               |
      | :---------- | :----------------------------------------------------- |
      | `abs()`     | 可以用来计算一个数的绝对值。                           |
      | `ceil()`    | 对数值进行上舍，即向上取整，小数位只要有值就自动进 1。 |
      | `floor()`   | 对数值进行下舍，即向下取整，小数位会被舍掉。           |
      | `round()`   | 对数值进行四舍五入。                                   |
      | `random()`  | 可以生成一个 0-1 之间的随机数。                        |
      | `max()`     | 可以获取多个数中的最大值。                             |
      | `min()`     | 可以获取多个数中的最小值。                             |
      | `pow(x, y)` | 返回 x 的 y 次幂。                                     |
      | `sqrt(x)`   | 返回 x 的开方后的值。                                  |

20. 包装类
    + JS 中数据类型：基本数据类型：String、Number、Boolean、Null、Undefined；引用数据类型：Object。
    + 在 JS 中为我们提供了三个包装类，通过这三个包装类可以将基本数据类型的数据转换为对象
      (1) `String()`：将一个基本数据类型字符串转换为 String 对象；
      (2) `Number()`：将一个基本数据类型数值转换为 Number 对象；
      (3) `Boolean()`：将一个基本数据类型布尔值转换为 Boolean 对象。
      (4) 注意：实际应用中基本不会使用基本数据类型的对象，如果使用基本数据类型的对象，在做一些比较时可能会带来一些不可预期的结果。
    + 方法和属性只能添加给对象，不能添加给基本数据类型，当我们对一些基本数据类型的值去调用属性和方法时，浏览器会临时使用包装类将其转换为对象，然后在调用对象的属性和方法，调用完之后在将其转换为基本数据类型。
    + 实际应用中用到最多的是字符串的方法，即字符串对象的方法：

      | 方法名           | 功能说明                                                                                                                                                                                                                                                     |
      | :--------------- | :----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
      | `charAt()`       | 可以返回字符串中指定位置的字符，根据索引获取指定的字符。                                                                                                                                                                                                     |
      | `charCodeAt()`   | 获取指定位置的字符的编码 Unicode 编码。                                                                                                                                                                                                                      |
      | `fromCharCode()` | 可以根据字符编码去获取字符。                                                                                                                                                                                                                                 |
      | `concat()`       | 可以用来链接两个或多个字符串。                                                                                                                                                                                                                               |
      | `indexOf()`      | 可以检索一个字符串中是否含有指定内容，如果字符串中含有改内容，则会返回其第一次出现的索引，如果没有找到指定的内容，则返回 -1；可以指定第二个参数，指定开始查找的位置。                                                                                        |
      | `lastIndexOf()`  | 该方法用法跟 `indexOf()` 类似，不同的是 `indexOf()` 从前往后找，`lastIndexOf()` 从后往前找。                                                                                                                                                                 |
      | `slice()`        | 可以从字符串中截取指定的内容，不会影响原数组，而是将截取的内容返回；第一个参数为开始位置索引(包括开始位置)，第二个参数为结束位置的索引(不包含结束位置位置)，如果省略第二个参数则会截取到后面所有字符，也就可以传递一个负数作为参数，负数的话将会从后边开始。 |
      | `substring()`    | 可以用来截取一个字符串，与 `slice()` 类似；第一个参数为开始位置索引(包括开始位置)，第二个参数结束位置的索引(不包含结束位置)；如果传递了一个负值，则默认使用 0，而且他还会自动调整，如果第二个参数小于第一个参数，则会自动变换参数位置。                      |
      | `substr()`       | 用来截取字符串，第一个参数为开始位置索引，第二个参数为截取字符的个数。                                                                                                                                                                                       |
      | `split()`        | 根据参数给定的字符将一个字符串拆分为数组，如果传递一个空串作为参数则将每个字符拆分为单独的数组元素。                                                                                                                                                         |
      | `toLowerCase()`  | 将字符串转换为小写，并返回新字符串。                                                                                                                                                                                                                         |
      | `toUpperCase()`  | 将字符串转换为大写，并返回新字符串。                                                                                                                                                                                                                         |

21. [正则表达式](https://www.w3school.com.cn/js/js_regexp.asp)
    + 用于定义一些字符串的规则，计算机可以根据正则表达式，来检查一个字符串是否符合规则，或者将字符串中符合规则的内容提取出来。
    + 创建一个正则对象的语法：

      ``` JavaScript
      var 变量名 = new RegExp("正则表达式", "匹配模式");
      ```

      如 `var reg = new RegExp("a");` 可以用来检查一个字符串中是否汉字字母 `a`；在构造函数中可以传递一个匹配模式作为第二个参数，可以是：`i` 表示忽略大小写，`g` 表示全局匹配模式；使用 `typeof` 检查一个正则对象，返回 object。
    + 正则表达式的方法：`test()`：使用这个方法可以用来检查一个字符串是否符合正则表达式的规则，如果符合则返回 `true`，否则返回 `false`。
    + 正则语法：
      (1) 使用字面量创建正则表达式语法：

        ``` JavaScript
        var 变量名 = /正则表达式/匹配模式;
        ```

      使用字面量的方式创建更加简单，使用构造函数创建更加灵活。
      (2) 使用 `|` 表示“或”的意思，使用 `[]` 里面的内容也是“或”的关系，`[ab] == a | b`，`[a-z]`：任意的小写字母，`[A-Z]`：任意的大写字母，`[A-z]`：任意的字母，`[0-9]`：任意数字；`[^ ab]`：检查一个字符串除了 `ab` 是否含有其他内容。匹配任意字母的时候注意 `[A-z]` 实际上是匹配 ASCⅡ 码 A-z 的所有字符，实际上包含几个字符，所以严格来说应该使用 `[A-Za-z]` 来匹配任意字母。
    + 字符串和正则相关的方法：

      | 方法名      | 功能介绍                                                                                                                                                                                                                                                                     |
      | :---------- | :--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
      | `split()`   | 可以将一个字符串拆分为一个数组，除了传递字符或字符串还可以传递以正则表达式作为参数，这样方法会根据正则表达式去拆分字符串，这个方法即使不指定全局匹配也会进行全局匹配。                                                                                                       |
      | `search()`  | 搜索字符串中是否含有指定内容，如果搜索到指定内容，则会返回第一次出现的索引，如果没有搜索到返回 -1；可以接收一个正则表达式作为参数，然后根据正则表达式去检索字符串，即使使用正则全局匹配也只会返回第一次满足条件的索引。                                                      |
      | `match()`   | 可以根据正则表达式，从一个字符串中将符合条件的内容提取出来，默认只会返回第一个符合条件的内容，可以设置正则为全局匹配模式，这样就会匹配到所有内容；可以为一个正则表达式设置多个匹配模式，且顺序无所谓；`match()` 会将匹配人的内容封装到一个数组中返回，即使只查询到一个结果。 |
      | `replace()` | 将字符串中指定内容替换为新的内容，第一个参数为被替换的内容，可以接收一个正则表达式作为参数，第二个参数为替换的新内容。默认只替换第一个符合条件的内容。                                                                                                                       |

    + 正则表达式语法
      (1) 量词：
        通过量词可以设置一个内容出现的次数，量词只对它前边的一个内容起作用，若要对一组起作用可使用 `()` 括起一组元素。

        | 量词    | 描述                                      |
        | :------ | :---------------------------------------- |
        | `{n}`   | 正好出现 n 次                             |
        | `{m,n}` | 出现 m-n 次                               |
        | `{m, }` | 出现 m 次以上                             |
        | `+`     | 至少一个，相当于 `{1,}`                   |
        | `*`     | 0 个或 0 个以上，相当于 `{0,}`            |
        | `?`     | 0 个或 1 个，相当于 `{0,1}`               |
        | `^n`    | 匹配以 n 开头的字符串                     |
        | `n$`    | 匹配以 n 结尾的字符串                     |
        | `?=n`   | 匹配任何其后紧接指定字符串 n 的字符串     |
        | `?!n`   | 匹配任何其后没有紧接指定字符串 n 的字符串 |

      (2) 元字符：
        在正则表达式中如果要匹配某些有其他用处的字符(如 `/`、`.` 等)需要使用 `\` 来进行转义，`\.` 表示 `.`，`\\` 表示 `\`；注意使用构造函数时，由于它的参数是字符串，而 `\` 是字符串中的转义字符，所以需要使用\时则需要 `\\` 来代替。

        | 元字符   | 描述                                                |
        | :------- | :-------------------------------------------------- |
        | `.`      | 表示任意字符                                        |
        | `\w`     | 匹配任意字母、数字和下划线_，相当于 `[A-za-z0-9_]`  |
        | `\W`     | 匹配除了字母、数字和下划线_，相当于 `[^A-za-z0-9_]` |
        | `\d`     | 匹配任意数字，相当于 `[0-9]`                        |
        | `\D`     | 匹配除了数字，相当于 `[^0-9]`                       |
        | `\s`     | 匹配空格                                            |
        | `\S`     | 匹配非空格                                          |
        | `\b`     | 匹配单词边界                                        |
        | `\B`     | 匹配除了单词边界                                    |
        | `\0`     | 查找 NULL 字符                                      |
        | `\n`     | 查找换行符                                          |
        | `\f`     | 查找换页符                                          |
        | `\r`     | 查找回车符                                          |
        | `\t`     | 查找制表符                                          |
        | `\v`     | 查找垂直制表符                                      |
        | `\xxx`   | 查找以八进制数 xxx 规定的字符                       |
        | `\xdd`   | 查找以十六进制数 dd 规定的字符                      |
        | `\uxxxx` | 查找以十六进制数 xxxx 规定的 Unicode 字符           |

22. [DOM](https://www.w3school.com.cn/js/js_htmldom.asp)(Document Object Model)文档对象模型
    + JS 中通过 DOM 来对 HTML 文档进行操作，只要理解了 DOM 就可以随心所欲的操作 Web 页面。
      (1) 文档：文档表示的就是整个 HTML 网页文档。
      (2) 对象：对象表示将网页中的每一个部分转换为了一个对象。
      (3) 模型：使用模型来表示对象之间的关系，这样方便我们获取对象。
    + 节点：
      (1) 节点 Node，是构成我们网页的最进本的组成部分网页中的每一个部分都可以称为是一个节点，比如 html 标签、属性、文本、注释、整个文档等都是一个节点。虽然都是节点，但是实际上他们的具体类型是不同的。比如：标签我们称为元素节点、属性我们称为属性节点、文本我们称为文本节点、文档我们称为文档节点。节点的类型不同，属性和方法也都不尽相同。
      (2) 常用节点分为四类：文档节点：整个 HTML 文档，元素节点：HTML 文档中的 HTML 标签，属性节点：元素的属性，文本节点：HTML 标签中的文本内容。
      (3) 节点的属性

        | 节点类型 | `nodeName` | `nodeType` | `nodeValue` |
        | :------- | :--------- | :--------- | :---------- |
        | 文档节点 | #document  | 9          | null        |
        | 元素节点 | 标签名     | 1          | null        |
        | 属性节点 | 属性名     | 2          | 属性值      |
        | 文本节点 | #text      | 3          | 文本内容    |

    + 事件：
      (1) 事件就是用户与浏览器之间的交互行为，比如：点击按钮、鼠标移动、关闭窗口。
      (2) 我们可以在事件对应的属性中设置一些 js 代码，这样当事件被触发时，这些代码将会执行；但是直接将 js 代码写到 html 标签中就造成了结构和行为的耦合，不方便维护，所以不推荐使用这种方式。
      (3) 我们通常使用的方式是对DOM元素对应事件绑定处理函数的形式来响应事件，当事件触发时，其对应的函数将会被调用，需要先获取要处理事件响应的 DOM 对象。
      语法：

      ``` JavaScript
      DOM元素对象.事件名称 = function(){
        事件响应所执行的代码
      }
      ```

      (3) [DOM元素事件对象](https://www.w3school.com.cn/jsref/dom_obj_event.asp)
    + 文档的加载
      (1) 浏览器在加载一个页面时，是从上往下开始加载的，读取到一行就运行一行，如果将 script 标签写到页面的上边，在代码执行时，页面还没有加载，DOM 对象也没有加载，则获取不到 DOM 元素。所以将 js 代码编写到页面的下部，就是在页面加载完毕以后再执行 js 代码。
      (2) 如果非要将 JS代 码写道页面上部，则需要注意若要获取 DOM 元素，需要再页面加载完毕之后再获取。
      (3) `onload` 事件会在整个页面加载完毕之后执行，支持该事件的对象有 image、layer、window。该事件对应的响应函数将会在页面加载完成之后执行，这样可以确保我们的代码执行时所有的 DOM 对象已经加载完毕了。所以我们如将 js 代码写到页面的上部，又要操作 DOM 元素则需要将代码编写到 window 对象的 onload 响应函数中。
    + DOM元素查询
      (1) 获取元素节点，通过 document 对象调用以下方法：

        | 方法名                   | 说明                             |
        | :----------------------- | :------------------------------- |
        | `getElementById()`       | 通过id属性获取一个元素节点对象   |
        | `getElementsByTagName()` | 通过标签名获取一组元素节点对象   |
        | `getElementsByName()`    | 通过name属性获取一组元素节点对象 |

      (2) 获取元素节点子节点(后代节点)，通过具体的元素节点调用以下方法或属性：

        | 方法或属性名             | 说明                                               |
        | :----------------------- | :------------------------------------------------- |
        | `getElementsByTagName()` | 方法，返回当前节点的指定标签名后代节点             |
        | `childNodes`             | 属性，表示当前节点的所有子节点                     |
        | `children`               | 属性，可以获取当前元素的所有子元素，IE8 以下不兼容 |
        | `firstChild`             | 属性，表示当前节点的第一个子节点                   |
        | `firstElementChild`      | 属性，获取当前元素的第一个子元素，不兼容 IE8 以下  |
        | `lastChild`              | 属性，表示当前节点的最后一个子节点                 |

      (3) 获取父节点或兄弟节点，通过具体的节点调用以下属性：

        | 属性名            | 说明                         |
        | :---------------- | :--------------------------- |
        | `parentNode`      | 表示当前节点的父节点         |
        | `previousSibling` | 表示当前节点的前一个兄弟节点 |
        | `nextSibling`     | 表示当前节点的后一个兄弟节点 |

      (4) 其他的几个 DOM 查询的属性和方法，通过 document 对象调用以下方法：

        | 方法或属性名               | 说明                                                                                                                                                                                                                                             |
        | :------------------------- | :----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
        | `body`                     | 属性，用来保存的是 body 的引用，类似与 `document.getElementByTagName("body")`                                                                                                                                                                    |
        | `documentElement`          | 属性，保存的是 html 根标签，类似与 `document.getElementByTagName("html")`                                                                                                                                                                        |
        | `all`                      | 属性，保存页面中所有所有元素，类似与 `document.getElementByTagName("*")`                                                                                                                                                                         |
        | `getElementsByClassName(`) | 方法，可以根据 class 属性值获取一组元素节点对象，不兼容 IE8 以下                                                                                                                                                                                 |
        | `querySelector()`          | 方法需要一个选择器的字符串作为参数,可以根据一个 CSS 选择器来查询一个元素的节点对象，虽然 IE8 中没有 `getElementsByClassName()` 但是可以使用 `querySelect()` 方法，使用该方法总会返回唯一的一个元素，如果满足条件的元素有多个，那么只会返回第一个 |
        | `querySelectAll()`         | 该方法和 `querySelect()` 类似，不同的是它会将符合条件的元素封装到一个数组返回，即使只有一个元素也会以数组的形式返回                                                                                                                              |

    + DOM 元素增删改

      | 方法名             | 说明                                                                                                                                  |
      | :----------------- | :------------------------------------------------------------------------------------------------------------------------------------ |
      | `appendChild()`    | 把新的子节点添加到指定节点，`父节点.appendChild(子节点);`                                                                             |
      | `removeChild()`    | 删除子节点，`父节点.removeChild(子节点);`;                                                                                            |
      | `replaceChild()`   | 替换子节点，`父节点.replaceChild(新节点, 旧节点);`                                                                                    |
      | `insertBefore()`   | 在指定的子节点前面插入新的子节点，`父节点.insertBefore(新节点, 旧节点);`                                                              |
      | `createElement()`  | 创建元素节点，需要一个标签名作为参数，将会根据标签名创建元素节点对象，并将创建好的对象作为返回值返回，`document.createElement("li");` |
      | `createTextNode()` | 创建文本节点，需要文本内容作为参数，将会根据内容创建文本节点，并将新的节点返回，`document.createElement("你好！");`                   |

23. style 样式获取与修改等
    + [使用 DOM 操作内联样式](https://www.w3school.com.cn/js/js_htmldom_css.asp)：
      (1) 通过 JS 修改元素的样式，语法：`元素.style.样式名 = 样式值;` 注意如果 CSS 的样式命中含有 `-`，这种名字在 JS 中是不合法的，如 `background-color`，需要将其修改为驼峰命名法，即去掉 `-` 后面的单词首字母大写，[JS 方式操作 style 属性名参考](https://www.w3school.com.cn/jsref/dom_obj_style.asp)。
      (2) 通过 style 属性设置的样式都是内联样式，内联样式有较高优先级，所以通过修改的样式往往会立即显示，但是如果在样式中写了 `!important`，则此时样式会有最高的优先级，及时通过 JS 也不能覆盖改样式，此时将会导致 JS 修改的样式失效，所以尽量不要为样式添加 `!important`。
      (3) 读取元素样式，语法：`元素.style.样式名`；通过 style 属性读取和设置的属性都是内联属性，无法读取样式表中的属性。
    + 通过 `currentStyle` 属性它可以用来读取当前元素正在显示(优先级高的样式优先显示)的样式，语法：`元素.currentStyle.样式名`；如果元素没有设置改样式，则获取它的默认样式。注意该属性只能在 IE 浏览器中使用并生效。
    + `getComputedStyle()` 方法可以获取元素当前的样式，这个方法是 window 对象的方法，可以直接使用。需要两个参数：第一个，需要获取的样式的元素；第二个，可以传递一个为元素(before、after)，一般都传 null。该方法返回一个对象，对象中封装了当前元素对应的样式。读取样式规则与 `currentStyle` 类似，可以通过 `对象.样式名` 来获取样式值，如果获取的样式没有设置，则会获取到真实的值，而不是默认值，比如没有设置 `width` 它不会获取到 auto`，而是实际长度。但是该方法不支持 IE8 及以下的浏览器。
    + 通过 `currentStyle` 属性和 `getComputedStyle()` 方法获取到的 style 属性值都是只读的，即不能通过此方式设置 style 属性值。
    + 其他样式相关的属性，这些属性获取的数据值都是不带 px 的，返回都是一个数字，可以直接进行计算；这些属性都是只读的，不能修改。

      | 属性名         | 说明                                                                                                               |
      | :------------- | :----------------------------------------------------------------------------------------------------------------- |
      | `clientWidth`  | 获取元素的可见宽度，包括内容区和内边距                                                                             |
      | `clientHeight` | 获取元素的可见高度，包括内容区和内边距                                                                             |
      | `offsetWidth`  | 获取元素的整个宽度，包括内容区、内边距和边框                                                                       |
      | `offsetHeight` | 获取元素的整个高度，包括内容区、内边距和边框                                                                       |
      | `offsetParent` | 获取当前元素的定位父元素，会获取到离当前元素最近的开启了定位的祖先元素，如果所有的祖先元素都没有开启定位则返回body |
      | `offsetLeft`   | 获取当前元素相对于其定位元素的水平偏移量                                                                           |
      | `offsetTop`    | 获取当前元素相对于其定位元素的垂直偏移量                                                                           |
      | `scrollWidth`  | 获取元素整个水平滚动区域的宽度                                                                                     |
      | `scrollHeight` | 获取元素整个垂直滚动区域的高度                                                                                     |
      | `scrollLeft`   | 获取水平滚动条滚动的距离                                                                                           |
      | `scrollTop`    | 获取垂直滚动条的垂直滚动距离                                                                                       |

      巧用属性：当元素满足 `scrollHeight - scrollTop == clientHeight` 的时候说明垂直滚动条滚动到最下侧了；当元素满足 `scrollWidth - scrollLeft == clientWidth` 的时候说明水平滚动条滚动倒最右侧了。
    + 通过 style 属性来修改元素的样式，每修改一个样式，浏览器就需要重新渲染一次页面，这样执行的性能是比较差的，而且这中形式当我们要修改多个样式时，也不太方便。我们希望执行一行代码就能够修改多个样式，我们可以通过修改元素的 class 属性来间接的修改样式，这样一来，我们只需要修改一次，即可同时修改多个样式，而且浏览器只需要重新渲染页面一次，性能较好，并且这种方式，可以时表现(HTML)和行为(JS)进一步分离。

24. 事件
    + [事件对象](https://www.w3school.com.cn/jsref/dom_obj_event.asp)：当事件的响应函数被触发时，浏览器每次都会将一个事件对象作为实参传递进响应函数，在事件对象中封装了当前事件相关的一切信息，比如：鼠标的坐标，键盘哪个案件配按下，鼠标滚轮的方向等。在 IE8 中响应函数被触发时，浏览器不会传递事件对象，在IE8及以下浏览器中，事件对象作为window对象的属性保存的，所以往往通过以下方法来解决事件对象的兼容性问题。

      ``` JavaScript
      // 方法一
      if(!event){
        event = window.event;
      }
      // 方法二
      event = event || window.event;
      ```

    + 事件冒泡(Bubble)，所谓的事件冒泡指的就是事件的向上传导，当后代元素上的事件被触发时，其祖先元素的相同事件也会被触发，在开发中大部分情况下冒泡都是有用的，如果不希望发生事件冒泡可以通过事件对象来取消事件冒泡，可以通过将事件对象的 `cancelBubble` 属性设置为 `true` 来取消事件冒泡。
    + 事件委派，指将事件统一绑定给元素的共同的祖先元素，这样当后代元素上的事件被触发时，会一直冒泡到祖先元素从而通过祖先元素的响应函数来处理事件；事件委派利用了事件冒泡，通过委派可以减少事件绑定的次数，提高程序性能。
    + 事件绑定
      (1) 使用 `对象.事件 = 事件响应函数;` 的形式为 DOM 对象绑定响应函数，它只能同时为一个元素绑定一个响应函数，不能绑定多个，如果绑定了多个，则后面会覆盖前面的。
      (2) `addEventListener()`：通过这个方法也可以为元素绑定响应函数。参数：事件名称字符串，不要带 `on` 了；回调函数，当事件触发时该函数会被调用；是否在捕获阶段触发事件，需要一个布尔值，一般都传 false。使用 `addEventListener()` 可以同时为一个元素的相同事件同时绑定多个响应函数，这样当事件被触发时，响应函数将会按照事件响应函数的绑定顺序执行。
      (3) `addEventListener()` 方法不支持 IE8 及以下浏览器，需要使用 `attachEvent()` 方法来进行事件绑定。参数：事件名称字符串，带 `on`；回调函数。这个方法也可以同时为一个事件绑定多个处理函数，不同的是后绑定先执行，执行顺序与 `addEventListener()` 相反。
      (4) `addEventListener()` 中的 this，是绑定的事件对象，`attachEvent()` 中的 this 是 window 对象，所以在做兼容性处理的时候要统一 this 指向。

        ``` JavaScript
        // 兼容性处理例子
        // 参数：1.obj，要绑定事件的对象，2.eventStr事件名称字符串(传递时不加on)，3.callback回调函数
        function bind(obj, eventStr, callback){
          if(obj.addEventListener){
            // 大部分浏览器兼通的方式
            obj.addEventListener(eventStr, callback, false);
          }else{
            /*
              this是谁是由调用方式决定的
              callback.call(obj)
            */
            // IE8及以下
            obj.attachEvent("on" + eventStr, function(){
              // 在匿名函数中条用回调函数
              callback.call(obj);
            });
          }
        }
        ```

    + 事件传播：
      (1) 关于事件的传播网景公司与微软公司有不同的理解。微软公司认为事件的传播是由内向外传播，也就是当事件触发时，应该先触发当前元素上的事件，然后再向元素的祖先元素上传播，也就是说事件应该在冒泡阶段执行。
      (2) 而网景公司认为事件应该是由外向内传播的，也就是当前事件触发时，应该先触发当前元素的最外层祖先元素，然后再向内传播给后代元素，也就是说事件应该再捕获阶段执行。
      (3) W3C 综合了两个公司的方案，将事件传播分成了三个阶段：捕获阶段，在捕获阶段时从最外层的祖先元素，向目标元素进行事件的捕获，但是默认此时不会触发事件；目标阶段，事件捕获到目标元素，捕获结束后开始在目标元素上触发事件；冒泡阶段，事件从目标元素向它的祖先元素传递，依次触发祖先元素上的事件。
      (4) 如果希望在捕获阶段就执行事件响应函数，则可以将 `addEventListener()` 的第三个参数设置为 `true`，但是一般情况下我们不会希望在捕获阶段触发事件，所以这个参数经常设置为 `false`。
      (5) IE8 及以下浏览器没有捕获阶段。
    + 鼠标滚轮事件：
      (1) `onmousewheel` 鼠标滚轮滚动事件，会在鼠标滚轮滚动时触发；但是在火狐中不支持该属性，在火狐中需要使用 `DOMMouseScroll` 来绑定滚动事件，注意该事件需要通过 `addEventListener()` 函数来绑定。
      (2) 判断鼠标滚轮滚动的方向，`event.wheelDelta` 可以获取鼠标滚轮滚动的方向，向上滚时 120 向下滚是 -120 不看大小，只看正负来判断上滚下滚；但是 `event.wheelDelta` 在火狐中不支持，需要使用 `event.delta` 来获取滚动的方向，向上滚 -3 向下滚 3。
      (3) 当鼠标滚轮滚动时，如果浏览器有滚动条，滚动条会随之滚动，这是浏览器的默认行为，如果不希望发生则需要 `return false;` 来取消默认行为；但是使用 `addEventListener()` 绑定的事件响应函数，取消默认行为时，不能使用 `return false;` 需要使用 `event.preventDefault()` 来取消默认行为，但是 IE8 不支持该方法。
    + 键盘事件：键盘事件一般绑定给一些可以获取焦点的对象或者是 document。
      (1) `onkeydown`：按键被按下，如果一直按住键盘某个按键不松手那么事件会一直在触发；当连续触发时，第一次和第二次之间会间隔稍微长一点，其他的会非常快，这种设计是防止误操作的发生。通过 `event.keyCode` 可以判断哪个按键被按下，除了 `event.keyCode`，事件对象还总还提供了几个属性 `altKey`、`ctrlKey`、`shiftKey` 这几个用来判断 alt、ctrl、shift 键是否被按下，如果按下则返回 `true` 否则返回 `false`。
      (2) `onkeyup`：按键被释放。
      (3) 在文本框中输入内容，属于 `onkeydown` 的默认行为，如果在 `onkeydown` 中取消默认行为，则输入的内容，不会出现在文本框中。

25. [BOM](https://www.w3school.com.cn/js/js_window.asp)
    + 浏览器对象模型（Browser Object Model (BOM)）允许 JavaScript 与浏览器对话。通过 BOM 我们可以通过 JS 来操作浏览器，在 BOM 中为我们提供了一组对象，用来完成对浏览器的操作
      BOM 对象：

      | 对象名    | 说明                                                                                                                                 |
      | :-------- | :----------------------------------------------------------------------------------------------------------------------------------- |
      | window    | 代表整个浏览器窗口，同时 window 也是网页中的全局对象                                                                                 |
      | Navigator | 代表当前浏览器的信息，通过该对象可以用来识别不同的浏览器                                                                             |
      | Location  | 代表当前浏览器的地址栏信息，通过 Location 可以获取地址栏信息，或者操作浏览器的跳转页面                                               |
      | History   | 代表浏览器的历史记录，可以通过该对象来操作浏览器的历史记录，由于隐私原因，该对象不能获取具体的历史记录，只能操作浏览器向前和向后翻页 |
      | Screen    | 代表用户的屏幕信息，通过该对象可以获取到用户的显示器的相关信息                                                                       |

    + Navigator 对象：由于历史原因，`Navigator` 中的大部分属性都已经不能帮助我们识别浏览器了，一般我们只会使用 `userAgent` 属性来判断浏览器信息，`userAgent` 是一个字符串，这个字符串包含有用来描述浏览器信息的内容，不同的浏览器会有不同的 `userAgent`；在 IE11 中已经将微软和 IE 相关的表示都已经去除了，所以我们基本已经不能通过 `userAgent` 来识别一个浏览器是否是 IE，可以通过 IE 浏览器独有的一些属性来进行判断，如 `ActiveXObject` 属性，我们可以通过判断 window 对象是否含有该属性(`"ActiveXObject" in window`)来判断是否是 IE 浏览器。
    + History 对象：可以用来操作浏览器向前向后翻页。

      | 属性名/方法名 | 说明                                                                                                                                                                                            |
      | :------------ | :---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
      | `length`      | 属性，可以获取到当前页面访问的链接数量                                                                                                                                                          |
      | `back()`      | 方法，可以用来退回到上一个页面，作用和浏览器的回退按钮一样                                                                                                                                      |
      | `forward()`   | 方法，可以用来前进到下一个页面，左右和浏览器的前进按钮一样                                                                                                                                      |
      | `go()`        | 方法，可以跳转到指定的页面，他需要一个整数作为参数，1 表示向前跳转一个页面相当于 `forward()`，2 表示向前跳转两个页面，-1 表示向后跳转一个页面相当于 `back()`，-2 表示向后跳转两个页面，以此类推 |

    + Location 对象：该对象封装了浏览器的地址栏的信息，如果直接打印 location 可以获取到地址栏的信息(当前页面完整路径)，如果直接将 location 属性修改为一个完成的路径或相对路径则我们页面会自动跳转到该路径，并且生成相应的历史记录。属性主要用来获取地址栏信息和 get/post 传递的数据信息，方法：

      | 方法名      | 说明                                                                           |
      | :---------- | :----------------------------------------------------------------------------- |
      | `assign()`  | 用来跳转到其他的页面，作用和直接修改 location 一样                             |
      | `reload()`  | 重新加载该网页，作用和刷新按钮一样，测试是否传递 `true` 都会强制清空缓存刷新   |
      | `replace()` | 使用新的页面替换当前页面，调用完毕也会跳转页面，但是不会生成历史记录，不可回退 |

    + window对象：
      (1) 定时器实现：`setInterval()` 定时调用，可以将一个函数，每隔一段时间执行一次；两个参数：回调函数，该函数会每隔一段时间被调用一次，每次调用间隔的事件，单位是毫秒；返回值：返回一个 Number 类新的数值，这个数值用来作为定时器的唯一标识。 `clearInterval()` 可以用来关闭一个定时器，方法中需要一个定时器标识作为参数，这样关闭表示对应的定时器。理论上 `clearInterval()` 可以接收任意参数，如果参数是一个有效的定时器的标识则定制对应的定时器，如果不是一个有效的表示，则什么也不做。
      (2) 延时调用：`setTimeout()` 延时调用一个函数不马上执行，而是隔一段时间以后再执行，而且只会执行一次，延时调用与定时调用的区别就是：定时调用会执行多次，而延时调用只会执行一次；使用 `clearTimeout()` 可以关闭一个延时调用。延时调用和定时调用用实际上是可以互相代替，在开发中根据自己需要进行选择。延时调用和关闭延时调用的使用方式与参数和定时器类似。

26. [JSON](https://www.w3school.com.cn/js/js_json_intro.asp)
    + JS 中的对象只有 JS 自己认识，其他的语言都不识别；JSON 就是要给特殊格式的字符串，这个字符串可以被任意的语言所识别，并且可以转换为任意语言中的对象，JSON 在开发中主要用来数据的交互。JavaScript Object Notation JS 对象表示法，JSON 和 JS 对象的格式一样，只不过 JSON 字符串的属性名必须加双引号，其他的和 JS 语法一致。
    + JSON 的分类：对象 `{}`，数组 `[]`。
    + JSON 中允许的值：字符串、数值、布尔值、null、对象、数组。
    + 将 JSON 字符串转换为 JS 中的对象，在 JS 中为我们提供了一个工具类，就叫 JSON，它即可以帮助我们将一个 JSON 转换为 JS 对象，也可以将一个 JS 对象转化为 JSON。
      (1) `JSON.parse()`：可以将一个 JSON 字符串转换为 JS 对象，需要一个 JSON 字符串作为参数，会将 JSON 字符串转化为 JS 对象并返回；
      (2) `JSON.stringify()`：可以将一个 JS 对象转化为 JSON 字符串，需要一个 JS 对象作为参数，会将转化 JSON 字符串返回。
    + JSON 对象在 IE7 及以下的浏览器中不支持，所以在这些浏览器中会报错，解决方法：
      (1) `eval()`：这个函数可以用来执行一段字符串形式的 JSON 代码，并将执行结果返回，如果使用 eval() 执行的字符串中含有 `{}`，它会将其当成代码块，如果不希望将其当成代码块则可以在字符串前后添加圆括号()。`eval()` 功能很强大，可以直接执行一个字符串的 js 代码，但是在开发中尽量不要使用，首先它的执行性能比较差，其次它具有一些安全隐患。
      (2) 如果需要兼容 IE7 及以下的浏览器的 JSO N操作，常用方法时通过引入一个外部的 js 文件处理包(json2.js)来提供对 JSON 的处理。

## JavaScript高级

1. 基础总结深入
    + 数据类型
      (1) 数据类型分类：

        | 基本(值)类型 | 说明               |
        | :----------- | :----------------- |
        | String       | 任意字符串         |
        | Number       | 任意数字           |
        | Boolean      | 两个值：true/false |
        | Undefined    | 唯一值：undefined  |
        | Null         | 唯一值：null       |

        | 对象(引用)类型 | 说明                                       |
        | :------------- | :----------------------------------------- |
        | Object         | 任意对象                                   |
        | Function       | 一种特别的对象(可以执行)                   |
        | Array          | 一种特别的对象(数值下标，内部数据是有序的) |

      (2)判断数据类型：

        | 方式         | 说明                                                                                                 |
        | :----------- | :--------------------------------------------------------------------------------------------------- |
        | `typeof`     | 可以判断 undefined、number、string、boolean、function，不可以判断 null 与 undefined、Object 和 Array |
        | `instanceof` | 判断对象的具体类型                                                                                   |
        | `===`        | 可以判断 undefined、null                                                                             |

    + 关于数据类型的三个小问题：
      (1) undefined 与n ull的区别？
        undefined 代表定义了未赋值，null 代表定义并赋值了，只是值为 null。
      (2) 什么时候给变量赋值为 null？
        初始将变量赋值为 null，表明该变量在程序后面会被赋值为一个对象；结束前将变量赋值为 null，让对象成为垃圾对象(被垃圾回收器回收)。
      (3) 严格区别变量类型与数据类型？
        数据的类型：基本类型、对象类型；变量的类型(变量内存值得类型)：基本类型，保存的就是基本类型的数据、引用类型，保存的地址的值。
    + 数据、变量与内存：
      (1) 什么是数据？
        存储在内存中代表特定信息的内容，本质上是由 01 构成的。
        数据的特点：可传递，可运算。
        一切皆数据，内存中所有操作的目标都是数据：算术运算、逻辑运算、赋值运算、运行函数。
      (2) 什么是内存？
        内存条通电以后产生的可存储数据的空间(临时的)；内存的产生与死亡：内存条(电路板)->通电->产生内存空间->存储数据->处理数据->断电->内存空间和数据都消失。
        一块小内存的两个数据：内部存储的数据，地址值。
        内存的分类：栈内存，存放全局变量和局部变量，空间较小；堆内存，存放对象本身，空间较大。
      (3) 什么是变量？
        可变化的量，由变量名和变量值组成，每个变量都有对应的一块小内存，变量名用来查找对应的内存，变量值就是内存中保存的数据
      (4) 内存、数据、变量三者之间的关系？
        内存是一个容器，是用来存储程序运行需要操作的数据，变量是内存的标识，我们通过变量找到对应的内存，进而操作(读/写)内存中的数据。
      (5) 问题1：`var a = xxx;` a 内存中到底保存的是什么？
        xxx 是基本数据类型，保存的就是这个数据；xxx 是对象，保存的是对象的地址值；xxx 是一个变量，保存的是 xxx 的内存内容(可能是基本数据，也可能是地址值)。
      (6) 问题2：关于引用变量赋值问题？
        两个(n个)引用变量指向同一个对象，通过一个变量修改对象内部数据，另一个(其他所有)变量可以看到的是修改之后的数据；两个引用变量指向同一个对象，让其中一个引用变量指向另一个对象，另一个引用变量依然指向之前的对象。
      (7) 问题3：在 js 调用函数传递变量参数时，是值传递还是引用传递？
        理解1：都是值传递(传递的变量的值)，只是这个值可能是基本值也可能是地址值。理解2：可能是值传递，也可能是引用传递(传递地址值)。
      (8) 问题4：JS 引擎如何管理内存？
        内存生命周期：分配所需内存空间，得到使用权->存储数据，可以反复进行操作->释放当前内存空间。释放内存：局部变量在使用完毕后自动释放，对象则在成为垃圾对象之后由垃圾回收器回收。
    + 对象
      (1) 什么是对象？
        多个数据的封装体(集合体)，用来保存多个数据的容器，一个对象代表现实中的一个事物，是该事物在编程中的抽象。
      (2) 为什么要用对象？
        统一管理多个数据。
      (3) 对象的组成是什么？
        属性：代表现实事物的状态的数据，由属性名(字符串)和属性值(任意类型)组成；方法：代表现实事务的行为数据，一种特殊的属性(属性值是函数)。
      (4) 如何访问对象内部数据？
        `对象.属性名`：编码简单，有时不能用；`对象['属性名']`：编码麻烦，能通用。
      (5) 问题：什么使用获取都能获取的属性值必须使用`对象["属性名"]`的形式？
        属性名包含特殊字符串(-、空格等)的时候；属性名不确定，属性名保存在其他变量中的时候。
    + 函数
      (1) 什么是函数？
        实现特定功能的 n 条语句的封装体，只有函数是可以执行的，其它类型的数据不能执行。
      (2) 为什么要用函数？
        提高代码复用，便于阅读交流。
      (3) 如何定义函数？
        函数声明，表达式。
      (4) 如何调用(执行)函数？
      直接调用，`test()`；通过对象调用，`obj.test();` new调用，`new test();` 临时让 test 成为 obj 的方法进行调用，`test.call(obj)/apply(obj)`。
      (5) 什么函数才是回调函数？
        你定义了，你没有调用，但是最终它执行了。
      (6) 常见的回调函数有哪些？
        DOM 事件回调函数(this->触发事件的 DOM 元素)，定时器回调函数(this->window)，ajax 请求回调函数，生命周期回调函数。
      (7) 自执行函数：全称：Immediately-Invoked Function Expression：立即执行函数表达式(匿名函数自调用)。作用：隐藏实现，不会污染外部(全局)命名空间，用它来编写 JS 模块。
      (8) 函数中的 this：
        this是什么？
        任何函数本质上都是通过某个对象来调用的，如果没有直接指定，那么就是 window；所有函数内部都有一个变量 this，它的值是调用函数的当前对象。
        如何确定 this 的值？
        根据谁调用函数来确定：`test()`，window；`p.test()`，p；`new test()`，新创建的对象；`p.call(obj)`，obj。

2. 函数高级
    + 函数原型：
      (1) 函数的 `prototype` 属性，每个函数都有一个 `prototype` 属性，它默认指向一个 Object 空对象(即称为：原型对象)，原型对象中有一个属性 `constructor`，它指向函数对象。
      (2) 给原型对象添加属性(一般都是方法)，作用：函数的所有实例对象自动拥有原型中的属性(方法)。
      构造函数与它的原型对象相互引用：
        ![示意图](https://i.loli.net/2019/11/11/pUXRn7T6MuS1PZd.png)
    + 显式原型与隐式原型：
      (1) 每个函数 `function` 都有一个 `prototype`，即显式原型(属性)；
      (2) 每个实例对象都有一个 `__proto__`，可称为隐式原型(属性)；
      (3) 对象的隐式原型的值为其对应构造函数的显式原型的值；
      (4) 内存结构
        ![内存结构图](https://i.loli.net/2019/11/12/iXC32BYW1ty85MS.jpg)
      (5) 总结：
        函数的 `prototype` 属性：在定义函数时自动添加的，默认值是一个空 Object 对象，对象的 `__proto__` 属性：创建对象时自动添加的，默认值为构造函数的 `prototype` 属性值(实例对象的隐式原型，默认指向构造函数的显式原型)，程序员能直接操作显式原型，但不能直接操作隐式原型(在ES6之前)。
    + 原型链：
      (1) 原型链：
        访问一个对象的属性时，先在自身属性中查找，找到则返回，如果没找到再沿着 `__proto__` 这条链向上查找，找到则返回，如果最终没找到则返回 `undefined`。别名：隐式原型链。作用：查找对象的属性(方法)。
      (2) 构造函数/原型/实体对象的关系(图解)
        ![三者关系](https://i.loli.net/2019/11/12/3HKwp6jT1E8cABq.jpg)
      (3) 原型继承：
        构造函数的实例对象自动拥有构造函数的原型对象的属性(方法)，利用的就是原型链。
      (4) 对象的属性(方法问题)：
        读取对象的属性值时，会自动到原型链中查找。设置对象的属性值时，不会查找原型链，如果当前对象中没有此属性，直接添加此属性并设置值。方法一般定义在原型中，属性一般通过构造函数定义在对象本身上。
      (5) 原型链补充：
        函数的显式原型指向的对象，默认是空 Object 的实例对象(但是 Object 不满足)。所有函数都是 Function 的实例，包括它本身。 Object 的原型对象是原型链尽头。
      (6) 探索 `instanceof`：
        `instanceof` 是如何判断的？表达式：`A instanceof B`；如果 B 函数的显式原型对象在 A 对象的原型链上，返回 `true`，否则返回 `false`。Function 是通过 `new` 自己产生的实例。
        案例1图解：
        ![案例1](https://i.loli.net/2019/11/13/AwB7hGZeICcQsLp.jpg)
        案例2图解：
        ![案例2](https://i.loli.net/2019/11/13/hHY7UTcqySl4X3k.jpg)
    + 执行上下文与上下文栈
      (1) 变量声明提升：
        通过 `var` 定义(声明)的变量，在定义语句之前就可以访问到，值为 `undefined`。
        函数声明提升：通过 `function` 声明的函数，在声明之前就可以直接调用，值为函数定义(对象)。
        那么就产生了问题：变量提升和函数提升是如何产生的？
      (2) 代码分类(位置)：
        全局代码，函数(局部)代码。
        全局执行上下文：在执行全局代码前将 window 确定为全局执行上下文。对全局数据进行预处理：`var` 定义的全局变量-->undefined，添加为 window 的属性；function 声明的全局函数-->赋值(fun)，添加为 window 的方法；`this`-->赋值(window)。开始执行全局代码。
        函数执行上下文：在调用函数，准备执行函数体之前，创建对应的函数执行上下文对象(虚拟的，存在于栈中)。对局部数据进行预处理：形参变量-->赋值(实参)-->添加为执行上下文的属性；`arguments`-->赋值(实参列表)，添加为执行上下文的属性；`var` 定义的局部变量-->undefined，添加为执行上下文的属性；function 声明的函数-->赋值(fun)，添加为执行上下文的方法；`this` -->赋值(调用函数的对象)。开始执行函数体代码。
      (3) 执行上下文栈：
        在全局代码执行前，JS 引擎就会创建一个栈来存储管理所有的执行上下文对象-->在全局执行上下文(window)确定后，将其添加到栈中(压栈)-->在函数执行上下文创建后，将其添加到栈中(压栈)-->在当前函数执行完后，将栈顶的对象移除(出栈)-->当所有的代码执行完后，栈中只剩下 window。
        案例：
        ![案例](https://i.loli.net/2019/11/14/Jzn7FaqAxYPjl15.jpg)
    + 作用域与作用域链
      (1) 作用域：
        理解：就是一块“地盘”，一个代码段所在的区域，他是静态的(相对于上下文对象)，在编写代码时就确定了。
        分类：全局作用域、函数作用域、没有块作用域(ES6 有了)。
        作用：隔离变量，不同的作用域下同名的变量不会有冲突。
      (2) 作用域与执行上下文栈的区别与联系：
        区别1：全局作用域之外，每个函数都会创建自己的作用域，作用域在函数定义时就已经确定了，而不是在函数调用时确定。全局执行上下文环境是在全局作用域确定之后，js 代码马上执行之前创建；函数执行上下文环境是在调用函数时，函数体代码执行之前创建。
        区别2：作用域是静态的，只要函数定义好了就一直存在，且不会再变化。执行上下文是动态的，调用函数时创建，函数调用结束时上下文环境就会自动释放。
        联系：执行上下文(对象)是从属于所在的作用域，全局上下文环境∈全局作用域，函数上下文环境∈对应的函数作用域。
      (3) 作用域链：
        理解：多个上下级关系的作用域形成的链，它的方向是从下向上的(从内到外)，查找变量时就是沿着作用域链来查找的。
        查找一个变量的查找规则：
        A. 在当前作用域下的执行上下文中查找对应的属性，如果有直接返回，否则进入 B；
        B. 在上一级作用域的执行上下文中查找对应的属性，如果有直接返回，否则进入 C；
        C. 再次执行 B 的相同操作，知道找到全局作用域，如果找到则返回，找不到就抛出找不到的异常。
    + 闭包(closure)
      (1) 如何产生闭包？
        当一个嵌套的内部(子)函数引用了嵌套的外部(父)函数的变量(函数)时，就产生了闭包。
        闭包是什么？
        使用 chrome 浏览器 debug 模式查看：理解一：闭包是嵌套的内部函数(绝大部分人)；理解二：内部函数中包含被引用变量(函数)的对象(极少数人)；注意：闭包存在于嵌套的内部函数中。
        产生闭包的条件：函数嵌套，内部函数引用了外部函数的数据(变量/函数)。
      (2) 常见的闭包：
        将函数作为另一个函数的返回；将函数作为实参传递给另一个函数调用。
      (3) 闭包的作用：
        使用函数内部的变量在函数执行完后，仍然存活在内存中(延长了局部变量的生命周期)；让函数外部可以操作(读写)到函数内部的数据(变量/函数)。
        问题：
        函数执行完后，函数内部声明的变量是否还存在？一般不存在，存在于闭包中的变量才可能存在。
        在函数外部能直接访问函数内部的局部变量吗？不能，但是我们可以通过闭包让外部操作它。
      (4) 闭包的应用：
        自定义 JS 模块(具有特定功能的 js 文件)，将所有的数据和功能都封装在一个函数内部(私有的)，只向外暴漏一个包含 n 个方法的对象或函数，模块的使用者，只需要通过模块暴漏的对象调用方法来实现对应的功能。
      (5) 闭包的的缺点与解决方法：
        缺点：函数执行完后，函数内的局部变量没有释放，占用内存时间会变长，容易造成内存泄露。
        解决：能不用闭包就不用闭包，及时释放内存。
      (6) 内存溢出与内存泄漏：
        是一种程序运行出现的错误，当程序运行需要的内存超过了剩余的内存时，就会抛出内存溢出的错误。
        内存泄漏：占用的内存没有及时释放，内存泄漏积累多了就容易导致内存移除；常见的内存泄漏有意外的全局变量、没有及时。
        清理的计时器或回调函数、闭包。

3. 对象高级
    + 对象创建模式：

      | 创建方式                | 过程                                                 | 适用场景                         | 存在问题                                 |
      | :---------------------- | :--------------------------------------------------- | :------------------------------- | :--------------------------------------- |
      | Object 构造函数模式     | 先创建空 Object 对象，再动态添加属性/方法            | 起始时不确定对象内部数据的情况下 | 语句太多                                 |
      | 对象字面量模式          | 使用 {} 创建对象，同时指定属性/方法                  | 起始时对象内部数据是确定的       | 如果创建多个对象，重复代码               |
      | 工厂模式                | 通过工厂函数动态创建对象并返回                       | 需要创建多个对象                 | 对象没有一个具体的类型，都是 Object 类型 |
      | 自定义构造函数模式      | 自定义构造函数，通过 new 创建对象                    | 需要创建多个类型确定的对象       | 每个对象都有相同的数据，浪费内存         |
      | 构造函数 + 原型组合模式 | 自定义构造函数，属性在函数中初始化，方法添加到原型上 | 需要创建多个类型确定的对象       |                                          |

    + 继承模式

      | 创建方式                      | 过程                                                                                                                                                                                                        | 关键                                                |
      | :---------------------------- | :---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | :-------------------------------------------------- |
      | 原型链继承                    | 定义父类型构造函数->给父类型的原型添加方法->定义子类型的构造函数->创建父类型的对象赋值给子类型的原型->将子类型原型的构造函数属性设置为子类型->给子类型原型添加方法-> 创建子类型的对象：可以调用父类型的方法 | 子类型的原型为父类型的一个实例对象                  |
      | 借用构造函数继承(假的继承)    | 定义父类型构造函数->定义子类型构造函数->在子类型构造函数中调用父类型构造                                                                                                                                    | 在子类型构造函数中通过 `super()` 调用父类型构造函数 |
      | 原型链+借用构造函数的组合继承 | 利用原型链实现对父类型对象的方法继承；利用 `super()` 借用父类型构造函数初始化相同属性                                                                                                                       |                                                     |

4. 线程机制与事件机制
    + 进程与线程
      (1) 进程(process)：
        程序的一次执行，他占有一片独有的内存空间，可以通过 windows 任务管理器查看进程。
      (2) 线程(thread)：
        是程序执行的一个完整流程，是 CPU 的最小的调度单元。
        ![进程线程关系图](https://i.loli.net/2019/11/18/pogO3NeDYZxIFl4.jpg)
      (3) 相关知识：
        应用程序必须运行在某个进程的某个线程上；一个进程至少有一个运行的线程：主线程，进行启动后自动创建；一个进程中也可以同时运行多个线程，我们会说程序是多线程运行的；一个进程内的数据可以供其中多个线程直接共享，多个进程之间的数据是不能直接共享的；线程池(thread pool)保存多个线程对象的容器，实现线程对象的反复利用。
      (4) 相关问题：
        何为多进程与多线程？
        多进程运行：一个应用程序可以同时启动多个实例运行；多线程：在一个进程中，同时有多个线程运行。
        比较单线程与多线程：
        多线程：优点，能有效提升 CPU 的利用率；缺点，创建多线程开销，线程间切换开销，死锁与状态同步问题。单线程：优点，顺序编程简单易懂；缺点，效率低。
        JS 是单线程还是多线程？
        JS 是单线程运行的，但使用 H5 中的 Web Workers 可以多线程运行。
        浏览器运行是单线程还是多线程？
        都是多线程运行的。
        浏览器运行是单进程还是多进程？
        有的是单进程：firefox，老版的 IE；有的是多进程：chrome，新版 IE 等。
    + 浏览器内核：支撑浏览器运行的最核心的程序；
      (1) 不同浏览器，它的内核可能不一样；Chrome、Safari：webkit；firefox：Gecko；IE：Trident；360，搜狗等国内浏览器：Trident + webkit。
      (2) 内核由很多模块组成
        主线程：JS 引擎模块，负责 js 程序的编译与运行；html、css 文档解析模块，负责页面文本的解析；DOM/CSS 模块：负责 DOM/CSS 在内存中的相关处理；布局和渲染模块，负责页面的布局和效果的绘制(内存中的对象)。
        ......
        分线程：定时器模块，负责定时器的管理；事件响应模块，负责事件的管理；网络请求模块，负责ajax请求。
    + 定时器引发的思考
      (1) 定时器真是定时执行吗？
        定时器并不能保证真正的定时执行，一般会延迟一丁点(可以接受)，也有可能延长很长时间(不能接受)。
      (2) 定时器回调函数是分线程执行的吗？
        在主线程执行的，js 是单线程的。
      (3) 定时器是如何实现的？
        事件循环模型。
    + JS 是单线程执行的
      (1) 如何证明 js 执行是单线程的：
        `setTimeout()` 回调函数是在主线程上执行的，定时器回调函数只有在运行栈中的代码全部执行完后才可能执行。
      (2) 为什么 js 要用单线程模式，而不是多线程模式？
        JavaScript 的单线程，与它的用途有关。作为浏览器脚本语言，JavaScript 的主要用途是与用户互动，以及操作 DOM。这决定了它只能是单线程，否则会带来很复杂的同步问题。
      (3) 代码的分类：
        初始化代码，回调代码。
      (4) js 引擎执行代码的基本流程：
        先执行初始化代码：包含一些特别的代码(设置定时器、绑定监听、发送 ajax 请求)；后面在某个时刻才会执行回调函数。
    + 浏览器的事件循环(轮询)模型
      (1) 事件循环模型原理图
        ![事件循环模型原理图](https://i.loli.net/2019/11/18/Q27NiOHzEXf6c9m.jpg)
      (2) 所有代码分类：初始化执行代码(同步代码)：包含绑定 DOM 事件监听、设置定时器、发送 ajax 请求的代码；回调执行代码(异步代码)：处理回调逻辑。
        js 引擎执行代码的基本流程：初始化代码-->回调代码
        模型的两个重要组成部分：时间管理模块，回调队列
        模型的运转流程：执行初始化代码，将事件回调函数交给对应模块管理；当事件发生时，管理模块会将回调函数及其数据添加到回调队列中；只有当初始化代码执行完后(可能需要一定时间)，才会遍历读取回调队列中的回调函数执行。
      (3) 相关重要概念：
        执行栈：execution stack，所有的代码都是在此空间中执行的。
        浏览器内核：browser core，js 引擎模块(在主线程处理)，其他模块(在主/分线程处理)。
        任务队列：task queue
        消息队列：message queue
        事件队列：event queue
        任务队列、消息队列、事件队列都是同一个 callback queue。
        事件轮询：event loop，从任务队列中循环取出回调函数放入执行栈中处理(一个接一个)。
        事件驱动模型：event-driven interaction model
        请求响应模型：request-response model
    + H5 Web Workers(多线程)
      (1) 介绍：
        Web Workers 使 HTML5 提供的一个 JavaScript 多线程解决方案，我们可以将一些大计算量的代码交由 Web Worker 运行而不冻结用户界面，但是子线程完全受主线程控制，且不得操作 DOM。所以这个新标准并没有改变 JavaScript 单线程的本质。
      (2) 使用：
        创建在分线程执行的 js 文件，在主线程的 js 中发消息并设置回调。
        相关 API：`Worker()`：构造函数，加载分线程执行的 js 文件；`Worker.prototype.onmessage()`：用于接收另一个线程的回调函数；`Worker.prototype.postMessage()`：向另一个线程发送消息。
        ![Web Workers工作流程](https://i.loli.net/2019/11/18/SFpxVBq7gQe9Ecv.png)
      (4) 不足：
        慢，Worker 内代码不能操作 DOM(更新 UI)，不能跨域加载 JS，不是每个浏览器都支持这个新特性。

## ES5、ES6、ES7

1. ECMA
    + 它是一种由 ECMA 组织(前身为欧洲计算机制造商协会)制定和发布的脚本语言规范，而我们学习的JavaScript是ECM的实现，但术语 ECMAScript 和 JavaScript 平时表达同一个意思。
    + JS 包含三个部分：ECMAScript (核心)；扩展(浏览器端)，DOM (文档对象模型)，BOM (浏览器对象模型)；扩展(服务器端)，Node.js。
    + ES 的几个重要版本：ES5，2009 年发布；ES6 (ES2015)，2015年发布，也称为 ECMA2015；ES7 (ES2016)，2016年发布，也称为 ECMA2016 (变化不大)。

2. ES5
    + 严格模式
      (1) 1.理解：
        除了正常运行模式(混杂模式)，ES5添加了第二种运行模式：“严格模式”(strict mode)。顾名思义，这种模式使得 JavaScript 在更严格的语法条件下运行。
      (2) 目的/作用：
        消除 JavaScript 语法的一些不合理、不严谨之处，减少一些怪异行为；消除代码运行的一些不安全之处，为代码安全运行保驾护航；为未来新版本的 JavaScript 做好铺垫。
      (3) 使用：
        在全局或函数的第一条语句定义为：`'use strict'`;如果浏览器不支持，只解析为一条简单的语句，没有任何副作用。
      (4) 语法和行为改变：
        必须用 var 关键字声明变量，禁止自定义的函数中的 `this` 指向 window，创建 `eval` 作用域，对象不能有重名的属性。
    + JSON 对象扩展
      (1) `JSON.stringify(obj/arr)`：将 js 对象(数组)转化为 json 对象(数组)
      (2) `JSON.parse(json)`：将 json 对象(数组)转换为 js 对象(数组)
    + Object 扩展
      (1) ES5给Object扩展了一些静态方法，常用的有两个：
      `Object.create(prototype, [descriptors])`
      作用：以指定对象为原型创建新的对象，为新的对象制定新的属性，并对属性进行描述。
      `prototype` 指定对象；后跟可选的 `descriptors` 描述，是一个键值对，键为属性名，值为一个对象，包含的属性有：`value`，指定属性值；`writable`，标识当前属性值是否是可修改的，默认为 `false`；`configurable`，表示当前属性是否可以被删除，默认为 `false`；`enumerable`，标识当前属性是否能用 `for in` 枚举，默认为 `false`。
      `Object.defineProperties(object, descriptors)`：
      作用：为指定对象定义扩展多个属性。
      `object` 为要扩展属性的对象；`descriptors` 描述，是一个键值对，键为属性名，值为一个对象：`get`：用来获取当前属性值的回调函数，`set`：修改当前属性值的触发的回调函数，并且实参即为修改后的值。
      存取器属性：`setter`，`getter`一个用来存值，一个用来取值。
      (2) 对象本身有两个方法：
      `get propertyName(){}` 用来得到当前属性值的回调函数；
      `set propertyName(){}` 用来监听当前属性值变化的回调函数。
    + Array 扩展
      以下这些方法都是给Array的实例使用的
      (1) `Array.prototype.indexOf(value)`：得到 `value` 值在数组中的第一个下标；
      (2) `Array.prototype.lastIndexOf(value)`：得到 `value` 值在数组中的最后一个下标；
      (3) `Array.prototype.forEach(function(item, index){})`：遍历数组；
      (4) `Array.prototype.map(function(item, index){})`：遍历数组返回一个新的数组，返回加工之后的值；
      (5) `Array.prototype.filter(function(item, index){})`：遍历过滤出一个新的子数组，返回条件为 `true` 的值。
    + Function扩展
    (1) `Function.prototype.bind(obj)`：作用将函数内的 `this` 绑定为 `obj`，并将函数返回。
    (2) 面试题：`bind()` 与 `call()` 和 `apply()` 的异同是什么？
    都能指定函数中的 this，`call()`、`apply()` 是立即调用函数，`bind()` 是将函数返回。

3. ES6
    + `let` 关键字：
      (1) 作用：与 `var` 关键字类似，用于声明一个变量。
      (2) 特点：在块作用域内有效；不能重复声明；不会预处理，不存在提升。
      (3) 应用：循环遍历加监听，使用 `let` 取代 `var` 是趋势。
    + `const` 关键字：
      (1) 作用：定义一个常量。
      (2) 特点：不能修改，其他特点同 `let` 关键字声明的变量。
      (3) 应用：保存不用改变的数据。
    + 模板字符串：用来简化字符串的拼接，模板字符串必须使用``来包括，变化的部分使用${xxx}来定义。

      ``` JavaScript
      let obj = {
        username: "kobe",
        age: 39
      };
      // 模板字符串
      let str = `我的名字是：${obj.username}，我的年龄：${obj.age}。`;
      console.log(str);
      ```

    + 简化的对象写法：属性名与属性值同名时可以省略属性值，只写一个属性名；方法可以直接声明，省去 `function` 关键字。

      ``` JavaScript
      let username = "kobe";
      let age = 39;

      let obj = {
        username, // 属性名与属性值同名可以省略属性值
        age,
        getName(){  // 方法直接声明，省去function关键字
            console.log(this.username);
        }
      }
      console.log(obj);
      ```

    + 箭头函数
      (1) 作用：用来定义匿名函数。
      (2) 基本语法：
        没有参数：`() => console.log("xxx")`;
        一个参数：`i => i + 2`;
        大于一个参数：`(i, j) => i + j`;
        函数体只有一条语句或表达式时，大括号可以省略，且省略后默认返回语句执行的结果或者是表达式的结果；函数体如果有多条语句需要使用 `{}` 包括函数体，如有需要返回的内容，需要手动返回。
      (3) 适用场景：多用来定义回调函数。
      (4) 箭头函数的特点：简洁；箭头函数没有自己的 `this`，箭头函数的 `this` 不是调用的时候决定的，而是在定义的时候所处的对象就是它的 `this`。扩展理解：箭头函数的 `this` 看外层是否有函数，如果有则外层函数的 `this` 就是内部箭头函数的 `this`；如果没有则 `this` 就是 `window`。
    + 三点运算符(点点点运算符)：
      用途：
      rest(可变)参数，用来取代arguments，但比arguments灵活，只能是最后部分形参参数

      ``` JavaScript
      function foo(a, ...value){
          console.log(value);
          value.forEach((item, index) => {
              console.log(item, index);
          })
      }
      foo(1, 2, 3);
      ```

      扩展运算符

      ``` JavaScript
      let arr = [1, 6];
      let arr1 = [2, 3, 4, 5];
      arr = [1, ...arr1, 6]; // 合并数组
      console.log(arr);
      console.log(...arr); // 整体输出数组中的每一项 1 2 3 4 5 6
      ```

    + 形参默认值：当不传入函数(方法)参数的时候默认使用形参的默认值。形参默认值的定义，在定义函数(方法)的时候在参数列表中为形参赋以默认值。

      ``` JavaScript
      function Point(x = 0, y = 0){  // 在形参列表中为形参指定默认值
          this.x = x;
          this.y = y;
      }
      let point = new Point();
      console.log(point);
      ```

    + Promise 对象
      (1) 理解：Promise 对象代表了未来某个将要发生的事件(通常是异步操作)；有了 Promise 对象，可以将异步操作以同步的流程表达出来，避免了层层嵌套的回调函数(俗称“回调地狱”)；ES6 的 Promise 是一个构造函数，用来生成 Promise 实例。
      (2) 使用 Promise 基本步骤(两步)：
        创建 promise 对象：

        ``` JavaScript
        let promise = new Promise((resolve, reject) => {
          // 初始化Promise对象的状态为pending
          // 执行异步操作
          if(异步操作成功){
            resolve(value); // 修改Promise对象的状态为fullfilled
          }else{
            reject(errMes); // 修改Promise对象的状态为rejected
          }
        });
        ```

        调用promise的then()：

        ``` JavaScript
        promise.then((result) => { // 异步操作成功的回调
          console.log(result);
        }, (errMsg) => {  // 异步操作失败的回调
          alert(errMsg);
        });
        ```

      (3) Promise 对象的三个状态：pending 初始化状态，fullfilled 成功状态，rejected 失败状态。
      (4) 应用：使用 Promise 实现超时处理，使用 Promise 封装处理 ajax 请求。
    + Symbol：
      (1) ES5 中对象的属性名都是字符串，容易造成重名，污染环境，所以在 ES6 中出现了 Symbol。
      (2) 概念：ES6 中添加了一种原始数据类型 symbol(已有的原始数据类型：String、Number、Boolean、Null、Undefined，对象)
      (3) 特点：
        Symbol 属性值对应的值是唯一的，解决命名冲突问题；
        Symbol 值不能与其他数据进行计算，包括同字符串拼串；
        `for in`、`for of` 遍历时不会遍历 symbol 属性。
      (4) 使用：
        调用 Symbol 函数得到 symbol 值

        ``` JavaScript
        let symbol = Symbol();
        let obj = {};
        obj[symbol] = 'hello';
        ```

        传参标识

        ``` JavaScript
        let symbol = Symbol("one");
        let symbol2 = Symbol("two");
        console.log(symbol); // Symbol("one")
        console.log(symbol2); // Symbol("two")
        ```

        内置 Symbol 值：除了定义自己使用的 symbol 值以外，ES6 还提供了 11 个内置的 Symbol 值，指向语言内部使用的方法。
        Symbol.iterator，对象的 Symbol.iterator 属性指向对象的默认遍历器方法。
    + iterator
      (1) 概念：iterator 是一种接口机制，为各种不同的数据结构提供统一的访问机制。
      (2) 作用：
        为各种数据结构，提供统一的、渐变的访问接口；
        使得数据结构的成员能够按某种次序排列；
        ES6 创造了一种新的遍历命令 `for of` 循环，Iterator 接口主要提供 `for of`。
      (3) 工作原理：
        创建一个指针对象(遍历器对象)，指向数据结构的起始位置；
        第一次调用 `next` 方法，指针自动指向数据结构的第一个成员；
        接下来不断调用 `next` 方法，指针会一直往后移动，直到指向最后一个成员；
        没调用 `next` 方法返回的是一个包含 `value` 和 `done` 的对象：`{ value: 当前的成员的值, done: 布尔值}`，`value` 表示当前成员的值，`done` 对应的布尔值表示当前的数据的结构是否遍历结束，当遍历结束时返回的 `value` 值是 `undefined`，`done` 值为 `true`。
      (4) 扩展理解：
        当数据结构上部署了 Symbol.iterator 接口，该数据就是可以用 `for of` 遍历；
        当使用 `for of` 去遍历目标数据的时候，该数据会自动去找 Symbol.iterator 属性；
        Symbol.iterator 属性指向对象的默认遍历器方法。
        ES6 已经将 iterator 接口部署到指定的数据类型上：`Array`、`String`、`arguments`、`set` 容器、`map` 容器。
      (5) 原生具备 iterator 结构的数据(可用 `for of` 遍历)；使用三点运算符、结构赋值默认去调用 iterator 接口。
    + Generator 函数
      (1) 概念：ES6 提供得解决异步编程的方案之一；Generator 函数是一个状态机，内部封装了不同状态的数据；用来生成遍历器对象；可暂停函数(惰性求值函数)，`yield` 可暂停，`next` 方法可启动。每次返回的是 `yield` 后的表达式结果。
      (2) 特点：
        `function` 与函数名之间有一个星号；
        内部用 `yield` 表达式来定义不同的状态；
        `generator` 函数返回的是指针对象(接 iterator 知识点)，而不会执行函数内部逻辑；
        调用 `next` 方法函数内部逻辑开始执行，遇到 `yield` 表达式停止，返回 `{value: yield后的表达式结果/undefined, done: boolean}`；
        再次调用 `next` 方法会从上一次停止时的 `yield` 处开始，直到最后；
        `yield` 语句返回结果通常为 `undefined`，当调用 `next` 方法时传参内容会作为启动时 `yield` 语句的返回值。
      (3) 语法：

        ``` JavaScript
        function* generatorExample(){
            let result = yield 'hello'; // 状态为'hello'
            yield 'generator'; // 状态值为generator
        }
        ```

    + async 函数(源自 ES2017/ES8)
      (1) 概念：真正意义上解决异步毁掉的问题，同步流程表达异步操作。
      (2) 本质：Generator 的语法糖。
      (3) 语法：

        ``` JavaScript
        async function foo(){
            await 异步操作;
            await 异步操作;
        }
        ```

      (4) 特点：
        不需要像 Generator 去调用 `next` 方法，遇到 `await` 等待，当前的异步操作完成就往下执行；
        返回的总是 Promise 对象，可以用 `then` 方法进行下一步操作；
        `async` 取代 Generator 函数的星号 `*`，`await` 取代 Generator 的 `yield`；
        语义上更为明确，使用简单，经临床验证暂时没有任何副作用及不良反应。
    + class 类
      (1) 通过 class 定义类，实现类的继承。
      (2) 在类中通过 `constructor` 定义构造方法。
      (3) 通过 `new` 来创建类的实例。
      (4) 通过 `extends` 来实现类的继承。
      (5) 通过 `super` 来调用父类的构造函数。
      (6) 重写从父类中继承的一般方法。
    + 字符串的扩展

      | 方法名            | 功能                     |
      | :---------------- | :----------------------- |
      | `includes(str)`   | 判断是否包含指定的字符串 |
      | `startsWith(str)` | 判断是否以指定字符串开头 |
      | `endsWith(str)`   | 判断是否以指定字符串结尾 |
      | `repeat(count)`   | 重复指定次数             |

    + 数值的扩展

      | 方法名                 | 功能                     |
      | :--------------------- | :----------------------- |
      | `0b`                   | 二进制表示法             |
      | `0o`                   | 八进制表示法             |
      | `Number.isFinite(i)`   | 判断是否是有限大的数     |
      | `Number.isNaN(i)`      | 判断时候是NaN            |
      | `Number.isInteger(i)`  | 判断时候是整数           |
      | `Number.parseInt(str)` | 将字符串转换为对应的数值 |
      | `Math.trunc(i)`        | 直接去除小数部分         |

    + 数组的扩展

      | 方法名                                                      | 功能                                                    |
      | :---------------------------------------------------------- | :------------------------------------------------------ |
      | `Array.from(v)`                                             | 将伪数组对象或可遍历对象转换为真数组                    |
      | `Array.of(v1, v2,v3)`                                       | 将一系列值转换成数组                                    |
      | `arr.find(function(value, index){ return 查询条件; })`      | 找出数组 `arr` 中第一个满足条件返回 `true` 的元素       |
      | `arr.findIndex(function(value, index){ return 查询条件; })` | 找出数组 a`rr` 中第一个满足条件返回 `true` 的元素的下标 |

    + 对象的扩展

      | 方法名                                        | 功能                           |
      | :-------------------------------------------- | :----------------------------- |
      | `Object.is(v1, v2)`                           | 判断两个数据是否完全相等       |
      | `Object.assign(target, source1, source2,...)` | 将源对象的属性赋值到目标对象上 |
      | `obj1.__proto__ = obj2;`                      | 直接操作 `__proto__` 属性      |

    + 浅拷贝与深拷贝
      (1) 拷贝数据：
        基本数据类型：拷贝后会生成一份新的数据，修改拷贝以后的数据不会影响原数据。
        对象/数组：拷贝后不会生成新的数据，而拷贝的是引用，修改拷贝以后的数据会影响原来的数据。
      (2) 常用的拷贝技术：
        直接复制给一个变量-浅拷贝
        `Object.assign()`-浅拷贝
        `arr.concat()`-数组浅拷贝
        `arr.slice()`-数组浅拷贝
        `JSON.parse(JSON.stringify(arr/obj))`-数组或对象的深拷贝，但不能处理函数数据；
        浅拷贝包含函数数据的对象/数组，拷贝的是引用，修改拷贝以后的数据会影响原数据；
        深拷贝包含函数数据的对象/数组，拷贝的时候生成新数据，修改拷贝后的数据不会影响原数据。
      (3) 实现深拷贝
        思考：如何实现深度拷贝(克隆)？
        当拷贝的数据里面有对象/数组时拷贝对象就会出现浅拷贝，要想实现深拷贝，则拷贝的数据中不能含有对象或数组；想要实现对像/数组的深度拷贝，就可以在遇到对象或数组的时候进一步对它进行遍历，直到遍历到的是基本数据类型，此时再去拷贝就是深度拷贝了。
        知识点储备：
        如何判断数据类型：arr --> Array，null --> Null...；`typeof` 返回的数据类型：String、Number、Boolean、Undefined、Object、Function，不能满足上述要求；使用 `Object.prototype.toString.call(obj)` 可以请确获取是数据类型。
        `for in` 语句实现循环遍历的知识

        ``` JavaScript
        // 定义一个检测数据类型的功能函数
        function checkedType(target){
          return Object.prototype.toString.call(target).slice(8, -1);
        }
        // 实现深度克隆 --> 更多针对的是数组、对象
        function clone(target){
          // result目标数据，targetType：原数据的数据类型
          let result, targeType = checkedType(target);
          if(targeType === 'Object'){
              result = {};  // 如果原数组是一个对象，则目标数据也是一个对象
          }else if(targeType === 'Array'){
              result = []; // 如果原数组是一个数组，则目标数据也是一个数组
          }else{
              return target; // 否则就是单一的可以直接拷贝的数据类型，直接返回
          }
          // 遍历对象/数组内所有项
          for(i in target){
              // 获取遍历数据结构的每一项
              let value = target[i];
              // 判断目标结构里的每一项是否为对象或数组
              if(checkedType(value) === 'Object' || checkedType(value) === 'Array'){
                  result[i] = clone(value); // 若子项还是对象或数组，递归克隆子项
              }else{
                  result[i] = value; // 否则直接返回可以拷贝的对象
              }
          }
          return result; // 返回深度克隆的数据
        }
        ```

    + Set 容器、Map 容器
      (1) Set 容器：无序且不可重复的多个value的集合体。

        | 方法或属性      | 说明                                            |
        | :-------------- | :---------------------------------------------- |
        | `Set()`         | 构造函数                                        |
        | `Set(array)`    | 使用构造函数对一个数组内元素进行唯一化          |
        | `add(value)`    | 往 set 容器中添加 `value` 值                    |
        | `delete(value)` | 从 set 容器中给删除 `value` 值                  |
        | `has(value)`    | 判断一个 set 容器中时候含有 `value` 值          |
        | `clear()`       | 清空 `set` 容器                                 |
        | `size`          | 获取 `set` 容器的大小，类似数组的 `length` 属性 |

      (2) Map 容器：无序的 `key` 不重复的多个 `key-value` 的集合体。

        | 方法或属性        | 说明                                                      |
        | :---------------- | :-------------------------------------------------------- |
        | `Map()`           | 构造函数                                                  |
        | `Map(array`)      | 将一个二维数组转换为 Map 对象实例                         |
        | `set(key, value)` | 往 map 容器中添加 `key-value` 值                          |
        | `get(key)`        | 获取 map 容器中 `key` 对应的 `value` 值                   |
        | `delete(key)`     | 删除 map 容器中 `key` 对应的 `key-value` 记录             |
        | `has(key)`        | 判断一个 map 容器中是否含有 `key` 对应的 `key-value` 记录 |
        | `clear()`         | 清空 map 容器                                             |
        | `size`            | 获取 map 容器大小                                         |

    + `for of` 循环遍历
      (1) 语法：`for(let value of target){}`
      (2) `for of` 可以遍历数组、Set、Map、字符串、伪数组。

4. ES7
    + 指数运算符(幂)：**
    + `Array.prototype.includes(value)`：判断数组中是否包含指定的 `value`。

## JS模块化

1. 理解
    + 什么是模块、模块化？
    将一个复杂的程序一句一定的规则(规范)封装成几个块(文件)，并进行组合在一起；块的内部数据/实现是私有的，只是向外暴漏一些接口(方法)与外部其他模块通信。
    + [JS 模块化进化史](https://www.cnblogs.com/LO-ME/p/7507146.html)
      (1) 全局 function 模式：将不同的功能封装成不同的全局函数中；全局环境被污染，容易引起命名冲突。
      (2) namespace 命名空间模式：简单的对象封装；减少了全局变量；不安全，数据不是私有的，外部可以修改。
      (3) IIFE(immediately-invoked function expression) 模式：匿名函数自调用(立即执行函数表达式)；数据是私有的，外部只能通过暴漏的方法来操作；但是没办法解决模块之间的依赖问题。
      (4) IIFE 模式增强：引入了模块之间的依赖，这就是现代模块实现的基石。
    + 为什么要模块化？
      (1) Web sites are turning into Web Apps：Web 站点正在变为 Web 应用
      (2) Code complexity grows as the site gets bigger：随着 Web 站点的增长，代码的复杂性也在增加
      (3) Highly decoupled JS files/modules is wanted：需要高度解耦的 JS 文件/模块
      (4) Deployment wants optimized code in few HTTP calls：部署需要在很少的 HTTP 调用中优化代码
    + 模块化的好处：
      (1) 避免命名冲突(减少命名空间污染)
      (2) 更好的分离，按需加载
      (3) 更高的复用性
      (4) 高可维护性
    + 页面可能需要多次引入加载 script ，带来了：请求过多、依赖模糊、难以维护等问题。
      一个页面需要引入多个 js 文件；带来的问题：请求过多、依赖模糊、难以维护；这些问题可以通过现代模块化编码和项目构建来解决。
      首先我们要依赖多个模块，那样就会发送多个请求，导致请求过多；然后就是依赖关系模糊，我们不知道他们的具体依赖关系是什么，也就是说很容易因为依赖关系而在引入 js 模块的时候顺序先后不对而带来问题。以上的现象就到这了这样会很难维护。很可能出现牵一发而动全身的情况导致项目出现严重的问题。

2. 模块化规范
    + CommonJS
      (1) 说明：每个文件都可当作一个模块；在服务器端：模块的加载就是运行时同步记载的；在浏览器端：模块需要提前编译打包处理。
      (2) 基本语法：
        暴漏模块：`module.exports = value;` 或 `export.xxx = value;`；暴漏模块本质是暴漏的 `exports` 对象。
        引入模块：`require(xxx)`，第三方模块：xxx为模块名，自定义模块：xxx为模块文件路径。
      (3) 实现：
        服务器端实现：Node.js；浏览器端实现：Browserify，也成为 CommonJS 的浏览器端的打包工具。

    + AMD
      (1) 说明：专门用于浏览器端的，模块的加载是异步的。
      (2) 基本语法：
        定义暴漏模块：

        ``` JavaScript
        // 定义没有依赖的模块
        define(function() {
          return 模块;
        });

        // 定义有依赖的模块
        define(['module1', 'module2'], function(m1, m2) {
          return 模块;
        });
        ```

        引入模块：

        ``` JavaScript
        require(['module1', 'module2'], function(m1, m2) {  // require关键字也可以使用requirejs
          使用模块m1、m2;
        });
        ```

      (3) 实现：Require.js

    + CMD
      (1) 说明：专门用于浏览器端的，模块的加载是异步的；模块使用时才回加载好。
      (2) 基本语法：
        定义暴漏模块：

        ``` JavaScript
        // 定义没有以来的模块
        define(function(require, exports, module) {
          exports.xxx = value;
          module.exports = value;
        });

        // 定义有依赖项的模块
        define(function(require, exports, module) {
          // 引入依赖模块(同步)
          var module2 = require('./module2');
          // 引入依赖模块(异步)
          require.async('./module3', function(m3) {

          });
          // 暴漏模块
          exports.xxx = value;
        });
        ```

        引入模块：

        ``` JavaScript
        define(function(require) {
          var m1 = require('./module1');
          var m2 = require('./module2');
          m1.show();
          m2.show();
        });
        ```

      (3) 实现：Sea.js

    + ES6
      (1) 说明：依赖模块需要编译打包处理。
      (2) 导出模块：`export`；导入模块：`import`。
      (3) 实现：使用 Babel 将 ES6 编译为 ES5 代码，使用 Browserify 编译打包 js。

## JS 数据结构与算法

1. 重要性

    (1) 什么是数据结构？
    + “数据结构是数据对象，以及存在该对象的实例和组成实例的数据元素之间的各种联系。这些联系可以通过定义相关的函数来给出。” --- 《数据结构、算法与应用》
    + “数据结构是 ADT（抽象数据类型 Abstract Data Type）的物理实现。” --- 《数据结构与算法分析》
    + “数据结构（data structure）是计算机中存储、组织数据的方式。通常情况下，精心选择的数据结构可以带来最优效率的算法。” --- 中文维基百科
    + 我们可以理解为数据结构就是在计算机中存储和组织数据的方式。

    (2) 什么是算法？
    + 一个有限指令集，每条指令的描述不依赖于语言；接受一些输入（有些情况下不需要输入）；产生输出；一定在有限步骤之后终止。
    + 算法通俗理解：Algorithm 这个单词本意就是解决问题的办法/步骤逻辑。数据结构的实现离不开算法。

2. 线性结构

    (1) 数组

    + [数组基础](https://www.jianshu.com/p/9521594710d7)
    + [数组基础 API](https://www.runoob.com/jsref/jsref-obj-array.html)
    + 补充：普通语言的数组封装，比如 Java 的 ArrayList：
      + 常见语言的数组不能存放不同的数据类型，因此所有在封装时通常存放在数组中的时 Object 类型；
      + 常见语言的数组容量不会自动改变，需要进行扩容操作；
      + 常见语言的数组进行中间插入和删除操作性能比较低。

    (2) 栈

    + 栈也是一种非常常见的数据结构，并且在程序中的应用非常广泛。
    + 数组：
      + 我们知道数组是一种线性结构，并且可以在数组的任意位置插入和删除数据；
      + 但是有时候，我们为了实现某些功能，必须对这种任意性加以限制；
      + 而栈和队列就是比较常见的受限的线性结构，我们先来学习栈结构。
    + 栈（stack），它是一种受限的线性表，后进先出（LIFO）：
      + 其限制是仅允许在表的一端进行插入和删除运算。这一端被称为栈顶，相对的把另一端称为栈底；
      + LIFO（last in first out）表示的就是后进入的元素，先弹出栈空间。
      + 向一个栈插入新元素又称作进栈、入栈或压栈，他是把新元素放到栈顶元素的上面，使之成为新的栈顶元素；
      + 从一个栈删除元素又称作出栈或退栈，它是把栈顶元素删除掉，使其相邻的元素成为新的栈顶元素。
    + ![进栈出栈操作](https://i.loli.net/2020/08/25/i58xgPhORmzT4kp.png)
    + 实现栈结构有两种比较常见的方式：基于数组实现，基于链表实现。
    + 栈常见的有哪些操作?

      | 方法名          | 作用                                                                       |
      | :-------------- | :------------------------------------------------------------------------- |
      | `push(element)` | 添加一个新元素到栈顶位置                                                   |
      | `pop()`         | 移除栈顶的元素，同时返回被移除的元素                                       |
      | `peek()`        | 返回栈顶的元素，不对栈做任何修改（这个方法不会移除栈顶的元素，仅仅返回它） |
      | `isEmpty()`     | 如果栈里没有任何元素就返回 `true`，否则返回 `false`                        |
      | `size()`        | 返回栈里的元素的个数。这个方法和数组的 `length` 属性很类似                 |
      | `toString()`    | 将栈结构的内容以字符串形式返回                                             |

    + 栈的应用：十进制转二进制

    (3) 队列

    + 队列（Queue）是一种受限的线性表，先进先出（FIFO First In First Out）。受限之处在于它只允许在表的前端（front）进行删除操作，而只能在表的后端（rear）进行删除操作。
    + ![进队出队操作](https://i.loli.net/2020/08/26/zcT2JRyYUOGKDlr.jpg)
    + 队列的实现和栈一样，有两种方案：基于数组实现、基于链表实现。
    + 队列常见的操作：

      | 方法名             | 作用                                                                                   |
      | :----------------- | :------------------------------------------------------------------------------------- |
      | `enqueue(element)` | 向队列尾部添加一个（或多个）新的项                                                     |
      | `dequeue()`        | 移除队列的第一（即排在队列最前面的）项，并返回被移除的元素                             |
      | `front()`          | 返回队列中的一个元素，最新被添加的也将是最先被移除的元素。该方法不会造成队列数据变动。 |
      | `isEmpty()`        | 如果队列中不包含任何元素，返回 `true`，否则返回 `false`                                |
      | `size()`           | 返回队列包含的元素个数，与数组的 `length` 属性类似                                     |
      | `toString()`       | 将队列中的内容，转成字符串形式                                                         |

    + 队列的应用：击鼓传花
    + 优先级队列：我们知道普通的队列插入一个元素，数据会被放在后端并且需要前面所有的元素都处理完成后才会处理前面的数据；但是优先级队列再插入一个元素的时候会考虑该数据的优先级。和其他数据优先级进行比较，比较完成后，可以得出这个元素在队列中正确的位置；其他处理方式和基本队列的处理方式一样。
    + 优先级队列主要考虑的问题，每个元素不再只是一个数据，而且包含数据的优先级，再添加方式中，根据优先级放入正确的位置。

    (4) 链表

    + 数组的缺点：数组的创建通常需要申请一段连续的内存空间（一整块的内存），并且大小是固定的（大多数编程语言数组都是固定的），所以当当前的数组不能满足容量需求时，需要扩容（一般情况下是申请一个更大的数组，比如 2 倍，然后将原数组中的元素复制过去）。而且数组开头或中间位置插入数据的成本很高，需要进行大量元素的位移。
    + 要存储多个元素，林外一个选择就是链表，但不同于数组，链表中的元素在内存中不必是连续的空间，链表的每个元素由一个存储元素本身的节点和一个指向下一个元素的引用（或称之为指针、连接）组成。
    + 相对于数组，链表有一些优点：内存空间不必是连续的，可以充分利用计算机的内存，实现灵活的内存动态管理；链表不必在创建时就确定大小，并且大小可以无限的延伸下去；链表在插入和删除数据时，时间复杂度可以达到 `O(1)`，相对数组效率高很多。
    + ![单向链表结构](https://i.loli.net/2020/08/28/N3th8opLB46ZlDz.jpg)
    + 单向链表常见的操作

      | 方法名                      | 作用                                                                                                 |
      | :-------------------------- | :--------------------------------------------------------------------------------------------------- |
      | `append(element)`           | 向列表的尾部添加一个新的项                                                                           |
      | `insert(position, element)` | 向列表的特定位置插入一个新的项                                                                       |
      | `get(position)`             | 获取对应位置的元素                                                                                   |
      | `indexOf(element)`          | 返回元素在链表中的索引，如果链表中那个没有该元素则返回 -1                                            |
      | `update(position, element)` | 修改某个位置的元素                                                                                   |
      | `removeAt(position)`        | 从链表的特定位置移除一项                                                                             |
      | `remove(position)`          | 从链表中移除一项                                                                                     |
      | `isEmpty()`                 | 如果链表中不包含任何元素返回 `true`，否则返回 `false`                                                |
      | `size()`                    | 返回链表包含的元素个数，与数组的 `length` 属性类似                                                   |
      | `toString()`                | 由于链表项使用了 `Node` 类，就需要重写继承自 Object 对象的默认的 `toString()` 方法，让其输出元素的值 |

    + 单向链表与双向链表

      | 比较项   | 单向链表                                                       | 双向链表                                                             |
      | :------- | :------------------------------------------------------------- | :------------------------------------------------------------------- |
      | 操作     | 只能从头遍历到尾或从玮到头（一般是从头到尾），单向链表是单向的 | 既可以从头遍历到尾，也可以从尾遍历到头；双向链表项链过程是双向的     |
      | 实现原理 | 上一个链表项中有一个指向下一个链表项的引用                     | 每一个链表项中既有指向前一个列表项的引用，也有指向下一个列表项的引用 |
      | 缺点     | 可以轻松到达下一个链表项，但是很难回到前一个链表项             | 每次在插入或删除某个列表项时需要处理四个引用                         |

    + ![双向链表结构图](https://i.loli.net/2020/08/31/NVyr2vwJ4aqIHQm.png)
    + 双向链表的基本操作

      | 方法名                      | 作用                                                                                                 |
      | :-------------------------- | :--------------------------------------------------------------------------------------------------- |
      | `append(element)`           | 向列表的尾部添加一个新的项                                                                           |
      | `insert(position, element)` | 向列表的特定位置插入一个新的项                                                                       |
      | `get(position)`             | 获取对应位置的元素                                                                                   |
      | `indexOf(element)`          | 返回元素在链表中的索引，如果链表中那个没有该元素则返回 -1                                            |
      | `update(position, element)` | 修改某个位置的元素                                                                                   |
      | `removeAt(position)`        | 从链表的特定位置移除一项                                                                             |
      | `remove(position)`          | 从链表中移除一项                                                                                     |
      | `isEmpty()`                 | 如果链表中不包含任何元素返回 `true`，否则返回 `false`                                                |
      | `size()`                    | 返回链表包含的元素个数，与数组的 `length` 属性类似                                                   |
      | `toString()`                | 由于链表项使用了 `Node` 类，就需要重写继承自 Object 对象的默认的 `toString()` 方法，让其输出元素的值 |
      | `forwardString()`           | 返回正向遍历的节点字符串形式                                                                         |
      | `backwardString()`          | 返回反向遍历的节点字符串形式                                                                         |

3. 集合与字典

    (1) 集合

    + 几乎每种编程语言中，都有几何结构。集合比较常见的实现方式是哈希表（后续学习），我们这里来实现一个封装的集合类。
    + 集合通常是由一组无序的，不能重复的元素构成。
    + 特殊的数组：特殊之处在于里面的元素没有顺序，也不能重复；没有顺序意味着不能通过下标值进行访问，不能重复意味着相同的对象在集合中只会存一份。
    + 2011 年 6 月份发布的 ES5 中已经包含了 Array 类；2015 年 6 月份发布的 ES6 中包含了 Set 类，所以实际上可以不封装直接使用它；但是为了明确集合的内部实现机制，我们这里还是自己来封装一下这个 Set 类。
    + 集合中常用的方法

      | 方法名          | 作用                                             |
      | :-------------- | :----------------------------------------------- |
      | `add(value)`    | 向集合添加一个新的项                             |
      | `remove(value)` | 从集合移除一个值                                 |
      | `has(value)`    | 弱国值在集合中返回 `true`，否则返回 `false`      |
      | `clear()`       | 移除集合中的所有项                               |
      | `size()`        | 返回集合所包含元素的数量，与数组的 `length` 类似 |
      | `values()`      | 返回一个包含集合中所有值的数组                   |

    + 集合间的操作
      + 并集：对于给定的两个集合，返回一个包含两个集合中所有元素的新集合。
      + 交集：对于给定的两个集合，返回一个包含两个集合中共有元素的新集合。
      + 差集：对于给定的两个集合，返回一个包含所有存在于第一个集合且不存在于第二个集合的新集合。
      + 子集：验证一个给定集合是否是另一个集合的子集。
      + ![集合的操作](https://i.loli.net/2020/09/04/PeAD5NBlGXamHYJ.jpg)

    (2) 字典

    + 数组、集合、字典是几乎所有编程语言都会默认提供的数据类型，JavaScript 在 ES6 中添加了集合与字典。
    + 字典的特点：字典的主要特点是一一对应的关系；比如保存一个人的信息，在合适的情况下取出这些信息：使用数组的方式：`[18, 'Coder', 1.88]`，可以通过下标值取出信息，使用字典的方式：`{'age': 18, 'name': 'Coder', 'height': 1.88}`，可以通过 `key` 取出 `value`，另外字典中的 `key` 是不可以重复的，而 `value` 可以重复，并且字典中的 `key` 是无序的。
    + 字典和映射的关系：
      + 有些编程语言中称这种映射关系为字典，因为它确实和生活中的字典比较相似（比如 Swift 中的 `Dictionary`，Python 中的 `dict`）
      + 有些编程语言中称这种映射关系为 `Map`，注意 `Map` 在这里不要翻译称地图，而是翻译成映射（比如 Java 中就有 `HashMap` 与 `TreeMap` 等）
    + 字典和数组：字典和数组对比的话，字典可以非常方便的通过 `key` 来搜索对应的 `value`，`key` 可以包含特殊含义，也更容易被人们记住。
    + 字典和对象：
      + 很多编程语言（比如 Java）中对字典和对象区别比较明显，对象通常是一种在编译期就确定下来的结构，不可以动态的添加或者删除属性。而字典通常会使用类似于哈希表的数据结构去实现一种可以动态的添加数据的结构。
      + 但是 JavaScript 中，似乎对象本身就是一种字典。所以在早期的 JavaScript 中，没有字典这种数据类型，因为你完全可以使用对象去代替。

4. 哈希表

    (1) 哈希表理论

    + 哈希表是一种非常重要的数据结构，但是很多学编程的人一直搞不懂哈希表到底是如何实现的。几乎所有的编程语言都有直接或间接的应用这种数据结构。
    + 哈希表通常是基于数组进行实现的，但是相对于数组，它也有很多的优势：
      + 它可以提供非常快速地插入-删除-查找操作；
      + 无论多少数据，插入和删除值需要接近常量的时间：`O(1)` 的时间级，实际上，只需要几个机器指令即可完成；
      + 哈希表的速度比树还要快，基本可以瞬间查找到想要的元素；
      + 哈希表相对于树来说编码要容易很多。
    + 哈希表相对于数组的一些不足：
      + 哈希表中的数据是没有顺序的，所以不能以一种固定的方式（比如从小到大）来遍历其中的元素。
      + 通常情况下，哈希表中的 `key` 是不允许重复的，不能防止相同的 `key`，用于保存不同的元素。
    + 那么什么是哈希表呢?
      + 哈希表不像数组和链表，甚至不像树一样直接画出你就知道他的结构。
      + 它的结构就是数组，但是它神奇的地方在于对下标值的一种变换，这种变换我们可以称之为哈希函数，通过哈希函数可以获取到 HashCode。
    + 认识哈希化
      + 哈希化：讲大数字转换成数组范围内下表的过程，我们称之为哈希化。
      + 哈希函数：通常我们会将单词转成大数字，大数字在进行哈希化的代码实现放在一个函数中，这个函数我们称为哈希函数。
      + 哈希表：最终将数据插入到的这个数组，对整个结构的封装，我们称之为一个哈希表。
    + 哈希化后的索引可能会存在重复，此时就会发生冲突。冲突是不可避免的，只能去解决冲突。
      + 链地址法，也称为拉链法：解决冲突的方法是每个数组单元中存储的不再是单个数据，而是一个链表。
      + ![链地址法](https://i.loli.net/2020/09/07/aDXZl8esQC4fSAb.jpg)
      + 开放地址法：主要工作方式是寻找空白的单元格来添加重复的数据，但是探索这个位置的方式不同，有三种方法：线性探测、二次探测、再哈希化。
      + ![开放地址法](https://i.loli.net/2020/09/07/Avy57bkSmPfrqEz.jpg)
    + 哈希化的效率，哈希表中执行插入和搜索操作效率是非常高的；如果没有产生冲突，那么效率就会很高；如果发生冲突，存取时间就依赖后来的探测长度；平均探测长度以及平均存取时间，取决于填装因子，随着填装因子变大，探测长度也越来越长。随着填装因子变大，效率下降的情况，在不同开放地址法方案中比链地址法更严重，所以我们来对比一下他们的效率，再决定我们选取的方案。
      + 线性探测效率：探测序列（P）和填装因子（L）的关系

        ``` bash
        对成功的查找：P = (1 + 1 / (1 - L)^2) / 2
        对不成功的查找：P = (1 + 1 / (1 - L)) / 2
        ```

      + 二次探测和再哈希化的性能相当（loadFactor 为装填因子），它们的性能比线性探测略好。

        ``` bash
        对成功的搜索：-log2 (1 - loadFactor) / loadFactor
        对不成功的搜索：1 / (1 - loadFactor)
        ```

      + 链地址法的效率：

        ``` bash
        成功可能只需要查找链表的一般即可：1 + loadFactor / 2
        不成功的查找可能需要将整个链表查询完才知道不成功：1 + loadFactor
        ```

    (2) 自定义哈希表

    + 哈希函数
    + 质数获取
    + 哈希表的存取等操作

5. 树结构

    (1) 树相关的概念

    + 树（Tree）：n（n ≥ 0）个节点构成的有限集合，当 n = 0 是，称为空树。
    + 对于任一棵非空树（n ＞ 0），它具备以下性质：数中有一个称为“根（Root）”的特殊节点，用 r 标识；其余节点可分为 m（m > 0）个互不相交的有限集 T1，T2，...，Tm，其中每个集合本身有是一棵树，称为原来树的“子树（SubTree）”。
    + 节点的度（Degree）：节点的子树个数。
    + 树的度：树的所有节点中最大的度数。
    + 叶节点（Leaf）：度为 0 的节点，也叫做叶子节点。
    + 父节点（Parent）：有子树的节点是其子树的根节点的父节点。
    + 子节点（Child）：若 A 节点是 B 节点的父节点，则称 B 节点是 A 节点的子节点；子节点也称孩子节点。
    + 兄弟节点（Sibling）：具有同一父节点的各节点彼此是兄弟节点。
    + 路径和路径长度：从节点 n1 到 nk 的路径为一个节点序列 n1，n2，...，nk，ni 是 ni+1 的父节点。路径所包含边的个数为路径的长度。
    + 节点的层次（Level）：规定根节点在 1 层，其他任意节点的层数是其父节点的的层数加 1。
    + 树的深度（Depth）：树中所有节点中的最大层次是这棵树的深度。
    + 树结构的两种表示方式：
      + ![普通表示法](https://i.loli.net/2020/09/11/kocqeXD6xJBONwa.jpg)
      + ![孩子兄弟表示法](https://i.loli.net/2020/09/11/hgDrsK7q5Iza3GW.jpg)

    (2) 二叉树

    + 如果树中每个节点最多只能有两个子节点，这样的树就称为“二叉树”。
    + 二叉树的定义：二叉树可以为空，也就是没有节点；若不为空，则它是由根节点和称为其左子树 TL 和右子树 TR 的两个不相交的二叉树组成。
    + ![二叉树的五种形态](https://i.loli.net/2020/09/12/ZQb4sjpm8q9SBnH.jpg)
    + 二叉树的特性：
      + 一个二叉树第 i 层的最大节点数为 2^(i-1), i≥1；
      + 深度为 k 的二叉树有最大节点总数为：2^k-1, K≥1；
      + 对任何非空二叉树 T，若 n0 标识叶节点的个数，n2 是度为 2 的非叶节点个数，那么两者满足关系 n0 = n2 + 1;
    + 完美二叉树（Perfect Binary Tree）也称为满二叉树（Full Binary Tree），即在二叉树中，除了最下一层的叶节点外，每层节点都有两个子节点，就构成了满二叉树。
    + 完全二叉树（Complete Binary Tree）：除二叉树最深一层外，其他各层的节点数都达到最大个数；且最深一层从左向右的叶节点连续存在，只缺右侧若干叶节点；完美二叉树是特殊的完全二叉树。
    + 二叉树的存储
      + 使用数组：完全二叉树可以按从上至下、从左到右顺序存储。非完全二叉树要转成完全二叉树才可以按照上面的方案存储，但是会造成很大的空间浪费。
      + ![完全二叉树存储](https://i.loli.net/2020/09/12/VP1X4sGjhk7FaOU.jpg)![非完全二叉树存储](https://i.loli.net/2020/09/12/DC1eB7t4q3OQUrs.jpg)
      + 二叉树最常见的方式还是使用链表存储，每个节点封装成一个 Node，Node 中包含存储的数据，左节点的引用和右节点的引用。
      + ![链表方式存储二叉树](https://i.loli.net/2020/09/13/zyYCHou5BNiAKIj.jpg)

    (2) 二叉搜索树

    + 二叉搜索树（BST，Binary Search Tree）也称二叉排序树或二叉查找树。
    + 因为二叉搜索树本身就是一颗二叉树，所以可以为空；如果二叉搜索树不为空，则满足以下性质：
      + 非空左子树的所有键值小于其根节点的键值，
      + 非空右子树的所有键值大于其根节点的键值，
      + 左右子树本身也都是二叉搜索树。
    + 二叉搜索树的特点：相对较小的值总是保存在左节点上，相对较大的值总是保存在右节点上。这个特点也就使得二叉搜索树的查找效率非常高。
    + 二叉搜索树常见的操作

      | 方法名                | 说明                                                                    |
      | :-------------------- | :---------------------------------------------------------------------- |
      | `insert(value)`       | 向树中插入一个新的值                                                    |
      | `search(value)`       | 在书中查找一个值，如果节点存在，则返回 `true`；如果不存在则返回 `false` |
      | `midOrderTraverse()`  | 通过中序遍历方式遍历所有节点                                            |
      | `preOrderTraverse()`  | 通过前序遍历方式遍历所有节点                                            |
      | `postOrderTraverse()` | 通过后序遍历方式遍历所有节点                                            |
      | `min()`               | 返回树中最小值                                                          |
      | `max()`               | 返回树中最大值                                                          |
      | `remove(value)`       | 从书中移除某个值                                                        |

    (3) 树的遍历

    + 遍历一棵树是指访问树的每个节点，但是树和线性结构不一样，线性结构我们通常按照从前往后的顺序遍历，但是树结构不同，树结构的遍历一般有：前序遍历、中序遍历、后序遍历。
    + 先序遍历：先访问根节点，先序遍历其左子树，先序遍历其右子树。
    + 中序遍历：先中序遍历其左子树，访问根节点，中序遍历其右子树。
    + 后序遍历：先后序遍历其左子树，后序遍历其右子树，访问根节点。

    (4) 二叉搜索树的删除

    + 删除叶子节点
    + 删除的节点有一个子节点
    + 删除的节点有左右两给子节点

    (5) 二叉树的补充

    + 二叉搜索树作为数据存储的结构有重要的优势：可以快速地找到给定关键字的数据项，并且可以快速地插入和删除数据项。
    + 但是二叉树有一个很麻烦的问题：比较好的二叉搜索树应该是左右分布均匀的，但是插入连续数据后，分布的不均匀，我们称这种树为非平衡树。对于一颗平衡二叉树来说插入/删除等操作哦的效率是 O(logN)，对于一颗非平衡二叉树，相当于编写了一个链表，查找效率变成了 O(N)。
    + 常见的平衡二叉树：AVL 树、红黑树。

    (6) 红黑树

    + 红黑树除了符合二叉搜索树的基本规则外，还添加了以下特性：
      + 节点是红色或黑色；
      + 根节点是黑色；
      + 每个叶子节点都是黑色的空节点（NIL 节点）；
      + 每个红色节点的两个子节点都是个黑色（从每个叶子到根的所有路径上不能有两个连续的红色节点）；
      + 从任一节点到其每个叶子的所有路径都包含相同数目的黑色节点。
    + 红黑树的相对平衡
      + 从根到叶子节点的最长可能路径，不会超过最短可能路径的两倍长，结果就是这棵树基本是平衡的，虽然没有做到绝对的平衡，但是可以保证在最坏的情况下，依然是高效的。
      + 为什么可以做到最长路径不超过最短路径的两倍呢：性质 4 决定了路径不能有两个相连的红色节点，最短的可能路径都是黑色节点，最长的路径是红色和黑色交替；性质 5 所有路径都有相同数目的黑色节点，这就表明了没有路径能多于任何其他路径的两倍长。

6. 图结构

    (1) 图相关概念

    + 图由一组结点与一组边组成，表示顶点与顶点之间的关系，是不能使用树来表示的。
    + 一组顶点：通常用 V（Vertex）表示边的集合。
    + 一组边：通常用 E（Edge）表示边的集合。
    + 边是顶点与顶点之间的连线，边可以是有向的（有向边：A->B）也可以是无向的（无向边：A-B）。
    + 顶点：表示图中的一个顶点。
    + 边：表示顶点与顶点之间的连线。
    + 相邻顶点：由一条边连接在一起的顶点称为相邻顶点。
    + 度：某个顶点的度为与该顶点相连的边的条数。
    + 路径：路径是顶点 v1，v2，...，vn 的一条通路。
    + 简单路径：简单路径要求不包含重复的顶点。
    + 回路：第一个顶点是最后一个顶点相同的路径称为回路。
    + 有向图：有向图表示的图中的边是有方向的。
    + 无向图：无向图表示的图中的边是无方向的。
    + 无权图：图中的边仅表示顶点与顶点之间的连接，除此之外没有其他意义。
    + 带权图：图中的边有一定的权重，权重可以代表顶点与顶点之间的连接的属性关系。

    (2) 图的表示

    + 顶点的表示相对简单，我们可以将顶点抽象为数字或字母表示，然后使用数组存储所有顶点。边的表示就有些麻烦了。
    + 邻接矩阵：
      + 邻接矩阵让每个顶点和一个整数相关联，该整数作为数组的下标值；我们用一个二维数组来表示顶点的连接。
      + 对于无权图，邻接矩阵中 0、1 表示顶点之间是否存在连线；对于带权图，邻接矩阵中可以使用权重值代替 1。
      + 邻接矩阵实际上可以使用二维数组来进行存储，使用二维数组可以很快地找到一个顶点与哪些顶点有连线。
      + 连接矩阵是一个对称矩阵。
      + 连接矩阵也存在一些问题：如果图是一个稀疏图，则矩阵中需要大量存储空间来存储表示没有连线的数字 0。
      + ![邻接矩阵](https://i.loli.net/2020/09/28/JXbPndHD1pL5Y3F.jpg)
    + 邻接表：
      + 邻接表由图中每个顶点以及和顶点相邻的顶点列表组成。这个列表有很多种方式来存储：数组/链表/哈希表都可以。
      + 使用连接表比较方便的查看顶点与顶点之间的连接情况，只需要在顶点对应的列表中查找即可。
      + 邻接表也存在一些问题：当图是有向图的时候，计算顶点的出度比较容易，但是计算顶点的入度则比较麻烦，需要构造一个“逆邻接表”。

    (3) 图的遍历

    + 广度优先搜索（Breadth-First Search，BFS）：基于队列，入队列的顶点先被探索。
    + 深度优先搜索（Depth-First Search，DFS）：基于栈或使用递归，通过将顶点存入栈中，顶点是沿着路径被探索的，存在新的相邻顶点就去访问。
    + 为了记录定点是否被访问过，使用三种颜色来反应它们的状态：白色，表示该顶点还没有被访问；灰色，表示该顶点被访问过，但并未被探索过；黑色，表示顶点被访问过且被完全探索过。

7. 排序 & 搜索

    (1) 简单排序

    + 冒泡排序
      + 冒泡排序相对于其他排序运行效率较低，但是在概念上它是排序算法中最简单的。
      + 冒泡排序的思路：对未排序的个元素从头到尾依次比较相邻的两个元素大小关系，如果前一个大则两个相互交换；然后继续向下比较两个数，当比较完一遍之后，最后面的数是最大的数，以此类推就可以将数据排序完成。
      + 比较次数：`N * (N - 1) / 2` O(N²)，比较次数：大约 `N * (N - 1) / 4` O(N²)
    + 选择排序
      + 选择排序的思路：选定第一个索引位置，然后与后面的元素一次比较，如果后面的小于第一个算因为之，则与之交换；这样经过一轮比较后，可以确定第一个位置是最小的，然后用同样的方法把剩下的元素逐个比较即可。
      + 交换次数：O(N)，比较次数：O(N²)
    + 插入排序
      + 插入排序是简单排序中效率最高的，也是学习其他高级排序的基础。
      + 插入排序的思想：插入排序思想的核心是局部有序，比如在一个队列中，我们选择其中一个作为标记，被标记的元素左边的所有元素已经是局部有序的，这意味着，有一部分元素是按顺序拍好的，另一部分还没有排好顺序。
      + 比较次数：平均需要 `N * (N - 1) / 4` 次，复制次数：最多 `N * (N - 1) / 2`。

    (2) 高级排序

    + 希尔排序
    + 快速排序
